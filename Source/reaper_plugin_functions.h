#ifndef _REAPER_PLUGIN_FUNCTIONS_H_
#define _REAPER_PLUGIN_FUNCTIONS_H_

// REAPER API functions
// Generated by REAPER v4.75/x64

/*
*  Copyright 2006-2014, Cockos Incorporated
*
*  This software is provided 'as-is', without any express or implied
*  warranty.  In no event will the authors be held liable for any damages
*  arising from the use of this software.
*
*  Permission is granted to anyone to use this software for any purpose,
*  including commercial applications, and to alter it and redistribute it
*  freely, subject to the following restrictions:
*
*  1. The origin of this software must not be misrepresented; you must not
*     claim that you wrote the original software. If you use this software
*     in a product, an acknowledgment in the product documentation would be
*     appreciated but is not required.
*  2. Altered source versions must be plainly marked as such, and must not be
*     misrepresented as being the original software.
*  3. This notice may not be removed or altered from any source distribution.
*/

// Note: the C++ pure virtual interfaces used require the MSVC-compatible C++ ABI on Win32.  Sorry, mingw users.
//
// Reaper extensions: see http://www.cockos.com/reaper/sdk/plugin/plugin.php and reaper_plugin.h.
// The API functions in this header can be retrieved using reaper_plugin_info_t.GetFunc().
//
// VST plugins: see http://www.cockos.com/reaper/sdk/vst/vst_ext.php
// The API functions in this header can be retrieved using audioMasterCallback.
//
// Because the API is dynamic, callers should never assume a function exists.
// Check that a non-NULL function pointer was returned before using it.

#if !defined(_LICE_H) && !defined(REAPERAPI_NO_LICE)
typedef unsigned int LICE_pixel;
typedef unsigned char LICE_pixel_chan;
class LICE_IBitmap;
class LICE_IFont;
#endif

class WDL_VirtualWnd_BGCfg;

// easiest to include reaper_plugin.h before reaper_plugin_functions.h in your application code.
// if not, you may need to edit this path.
#ifndef _REAPER_PLUGIN_H_
#include "reaper_plugin.h"
#endif

#ifndef REAPERAPI_DECL
#define REAPERAPI_DECL extern
#endif

#ifndef REAPERAPI_STUBNAME
#define REAPERAPI_STUBNAME(x) x
#endif

#ifndef REAPERAPI_DECLFUNC
#define REAPERAPI_DECLFUNC(r,f) REAPERAPI_DECL r (*REAPERAPI_STUBNAME(f))
#endif


class AudioAccessor;

// __mergesort is a stable sorting function with an API similar to qsort().
// HOWEVER, it requires some temporary space, equal to the size of the data being sorted, so you can pass it as the last parameter,
// or NULL and it will allocate and free space internally.
REAPERAPI_DECLFUNC(void,__mergesort)(void* base, size_t nmemb, size_t size, int (*cmpfunc)(const void*,const void*), void* tmpspace);

// menuidstr is some unique identifying string
// menuname is for main menus only (displayed in a menu bar somewhere), NULL otherwise
// kbdsecname is the name of the KbdSectionInfo registered by this plugin, or NULL for the main actions section
REAPERAPI_DECLFUNC(bool,AddCustomizableMenu)(const char* menuidstr, const char* menuname, const char* kbdsecname, bool addtomainmenu);

// Add an Extensions main menu, which the extension can populate/modify with plugin_register("hookcustommenu")
REAPERAPI_DECLFUNC(bool,AddExtensionsMainMenu)();

// creates a new media item.
REAPERAPI_DECLFUNC(MediaItem*,AddMediaItemToTrack)(MediaTrack* tr);

// Returns the index of the created marker/region, or -1 on failure. Supply wantidx>=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use.
REAPERAPI_DECLFUNC(int,AddProjectMarker)(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx);

// Returns the index of the created marker/region, or -1 on failure. Supply wantidx>=0 if you want a particular index number, but you'll get a different index number a region and wantidx is already in use. color should be 0 or RGB(x,y,z)|0x1000000
REAPERAPI_DECLFUNC(int,AddProjectMarker2)(ReaProject* proj, bool isrgn, double pos, double rgnend, const char* name, int wantidx, int color);

// creates a new take in an item
REAPERAPI_DECLFUNC(MediaItem_Take*,AddTakeToMediaItem)(MediaItem* item);

// Deprecated. Use SetTempoTimeSigMarker with ptidx=-1.
REAPERAPI_DECLFUNC(bool,AddTempoTimeSigMarker)(ReaProject* proj, double timepos, double bpm, int timesig_num, int timesig_denom, bool lineartempochange);

// forceset=0,doupd=true,centermode=-1 for default
REAPERAPI_DECLFUNC(void,adjustZoom)(double amt, int forceset, bool doupd, int centermode);

REAPERAPI_DECLFUNC(bool,AnyTrackSolo)(ReaProject* proj);

REAPERAPI_DECLFUNC(void,APITest)();

// nudgeflag: &1=set to value (otherwise nudge by value), &2=snap
// nudgewhat: 0=position, 1=left trim, 2=left edge, 3=right edge, 4=contents, 5=duplicate, 6=edit cursor
// nudgeunit: 0=ms, 1=seconds, 2=grid, 3=256th notes, ..., 15=whole notes, 16=measures.beats (1.15 = 1 measure + 1.5 beats), 17=samples, 18=frames, 19=pixels, 20=item lengths, 21=item selections
// value: amount to nudge by, or value to set to
// reverse: in nudge mode, nudges left (otherwise ignored)
// copies: in nudge duplicate mode, number of copies (otherwise ignored)
REAPERAPI_DECLFUNC(bool,ApplyNudge)(ReaProject* project, int nudgeflag, int nudgewhat, int nudgeunits, double value, bool reverse, int copies);

// is in pre-buffer? threadsafe
REAPERAPI_DECLFUNC(int,Audio_IsPreBuffer)();

// is audio running at all? threadsafe
REAPERAPI_DECLFUNC(int,Audio_IsRunning)();

// return >0 on success
REAPERAPI_DECLFUNC(int,Audio_RegHardwareHook)(bool isAdd, audio_hook_register_t* reg);

// Validates the current state of the audio accessor -- must ONLY call this from the main thread. Returns true if the state changed.
REAPERAPI_DECLFUNC(bool,AudioAccessorValidateState)(AudioAccessor* accessor);

// -1 = bypass all if not all bypassed,otherwise unbypass all
REAPERAPI_DECLFUNC(void,BypassFxAllTracks)(int bypass);

REAPERAPI_DECLFUNC(int,CalculatePeaks)(PCM_source_transfer_t* srcBlock, PCM_source_peaktransfer_t* pksBlock);

// NOTE: source samples field is a pointer to floats instead
REAPERAPI_DECLFUNC(int,CalculatePeaksFloatSrcPtr)(PCM_source_transfer_t* srcBlock, PCM_source_peaktransfer_t* pksBlock);

REAPERAPI_DECLFUNC(void,ClearAllRecArmed)();

// resets the global peak caches
REAPERAPI_DECLFUNC(void,ClearPeakCache)();

// Returns the number of shortcuts that exist for the given command ID.
// see GetActionShortcutDesc, DeleteActionShortcut, DoActionShortcutDialog.
REAPERAPI_DECLFUNC(int,CountActionShortcuts)(KbdSectionInfo* section, int cmdID);

// count the number of items in the project (proj=0 for active project)
REAPERAPI_DECLFUNC(int,CountMediaItems)(ReaProject* proj);

// num_markersOut and num_regionsOut may be NULL.
REAPERAPI_DECLFUNC(int,CountProjectMarkers)(ReaProject* proj, int* num_markersOut, int* num_regionsOut);

// count the number of selected items in the project (proj=0 for active project)
REAPERAPI_DECLFUNC(int,CountSelectedMediaItems)(ReaProject* proj);

// count the number of selected tracks in the project (proj=0 for active project)
REAPERAPI_DECLFUNC(int,CountSelectedTracks)(ReaProject* proj);

// count the number of takes in the item
REAPERAPI_DECLFUNC(int,CountTakes)(MediaItem* item);

// Count the number of FX parameter knobs displayed on the track control panel.
REAPERAPI_DECLFUNC(int,CountTCPFXParms)(ReaProject* project, MediaTrack* track);

// Count the number of tempo/time signature markers in the project. See GetTempoTimeSigMarker, SetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECLFUNC(int,CountTempoTimeSigMarkers)(ReaProject* proj);

// see GetTrackEnvelope
REAPERAPI_DECLFUNC(int,CountTrackEnvelopes)(MediaTrack* track);

// count the number of items in the track
REAPERAPI_DECLFUNC(int,CountTrackMediaItems)(MediaTrack* track);

// count the number of tracks in the project (proj=0 for active project)
REAPERAPI_DECLFUNC(int,CountTracks)(ReaProject* proj);

// callback is a function pointer: void (*callback)(void* obj, const char* msg, int msglen), which handles OSC messages sent from REAPER. The function return is a local osc handler. See SendLocalOscMessage, DestroyOscHandler.
REAPERAPI_DECLFUNC(void*,CreateLocalOscHandler)(void* obj, void* callback);

REAPERAPI_DECLFUNC(midi_Input*,CreateMIDIInput)(int dev);

REAPERAPI_DECLFUNC(midi_Output*,CreateMIDIOutput)(int dev, bool streamMode, int* msoffset100);

// Create a new MIDI media item, containing no MIDI events.
REAPERAPI_DECLFUNC(MediaItem*,CreateNewMIDIItemInProj)(MediaTrack* track, double starttime, double endtime);

// Create an audio accessor object for this take. Must only call from the main thread. See CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECLFUNC(AudioAccessor*,CreateTakeAudioAccessor)(MediaItem_Take* take);

// Create an audio accessor object for this track. Must only call from the main thread. See CreateTakeAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECLFUNC(AudioAccessor*,CreateTrackAudioAccessor)(MediaTrack* track);

// call this to force flushing of the undo states after using CSurf_On*Change()
REAPERAPI_DECLFUNC(void,CSurf_FlushUndo)(bool force);

REAPERAPI_DECLFUNC(bool,CSurf_GetTouchState)(MediaTrack* trackid, int isPan);

REAPERAPI_DECLFUNC(void,CSurf_GoEnd)();

REAPERAPI_DECLFUNC(void,CSurf_GoStart)();

REAPERAPI_DECLFUNC(int,CSurf_NumTracks)(bool mcpView);

REAPERAPI_DECLFUNC(void,CSurf_OnArrow)(int whichdir, bool wantzoom);

REAPERAPI_DECLFUNC(void,CSurf_OnFwd)(int seekplay);

REAPERAPI_DECLFUNC(bool,CSurf_OnFXChange)(MediaTrack* trackid, int en);

REAPERAPI_DECLFUNC(int,CSurf_OnInputMonitorChange)(MediaTrack* trackid, int monitor);

REAPERAPI_DECLFUNC(int,CSurf_OnInputMonitorChangeEx)(MediaTrack* trackid, int monitor, bool allowgang);

REAPERAPI_DECLFUNC(bool,CSurf_OnMuteChange)(MediaTrack* trackid, int mute);

REAPERAPI_DECLFUNC(bool,CSurf_OnMuteChangeEx)(MediaTrack* trackid, int mute, bool allowgang);

REAPERAPI_DECLFUNC(void,CSurf_OnOscControlMessage)(const char* msg, const float* arg);

REAPERAPI_DECLFUNC(double,CSurf_OnPanChange)(MediaTrack* trackid, double pan, bool relative);

REAPERAPI_DECLFUNC(double,CSurf_OnPanChangeEx)(MediaTrack* trackid, double pan, bool relative, bool allowGang);

REAPERAPI_DECLFUNC(void,CSurf_OnPause)();

REAPERAPI_DECLFUNC(void,CSurf_OnPlay)();

REAPERAPI_DECLFUNC(void,CSurf_OnPlayRateChange)(double playrate);

REAPERAPI_DECLFUNC(bool,CSurf_OnRecArmChange)(MediaTrack* trackid, int recarm);

REAPERAPI_DECLFUNC(bool,CSurf_OnRecArmChangeEx)(MediaTrack* trackid, int recarm, bool allowgang);

REAPERAPI_DECLFUNC(void,CSurf_OnRecord)();

REAPERAPI_DECLFUNC(double,CSurf_OnRecvPanChange)(MediaTrack* trackid, int recv_index, double pan, bool relative);

REAPERAPI_DECLFUNC(double,CSurf_OnRecvVolumeChange)(MediaTrack* trackid, int recv_index, double volume, bool relative);

REAPERAPI_DECLFUNC(void,CSurf_OnRew)(int seekplay);

REAPERAPI_DECLFUNC(void,CSurf_OnRewFwd)(int seekplay, int dir);

REAPERAPI_DECLFUNC(void,CSurf_OnScroll)(int xdir, int ydir);

REAPERAPI_DECLFUNC(bool,CSurf_OnSelectedChange)(MediaTrack* trackid, int selected);

REAPERAPI_DECLFUNC(double,CSurf_OnSendPanChange)(MediaTrack* trackid, int send_index, double pan, bool relative);

REAPERAPI_DECLFUNC(double,CSurf_OnSendVolumeChange)(MediaTrack* trackid, int send_index, double volume, bool relative);

REAPERAPI_DECLFUNC(bool,CSurf_OnSoloChange)(MediaTrack* trackid, int solo);

REAPERAPI_DECLFUNC(bool,CSurf_OnSoloChangeEx)(MediaTrack* trackid, int solo, bool allowgang);

REAPERAPI_DECLFUNC(void,CSurf_OnStop)();

REAPERAPI_DECLFUNC(void,CSurf_OnTempoChange)(double bpm);

REAPERAPI_DECLFUNC(void,CSurf_OnTrackSelection)(MediaTrack* trackid);

REAPERAPI_DECLFUNC(double,CSurf_OnVolumeChange)(MediaTrack* trackid, double volume, bool relative);

REAPERAPI_DECLFUNC(double,CSurf_OnVolumeChangeEx)(MediaTrack* trackid, double volume, bool relative, bool allowGang);

REAPERAPI_DECLFUNC(double,CSurf_OnWidthChange)(MediaTrack* trackid, double width, bool relative);

REAPERAPI_DECLFUNC(double,CSurf_OnWidthChangeEx)(MediaTrack* trackid, double width, bool relative, bool allowGang);

REAPERAPI_DECLFUNC(void,CSurf_OnZoom)(int xdir, int ydir);

REAPERAPI_DECLFUNC(void,CSurf_ResetAllCachedVolPanStates)();

REAPERAPI_DECLFUNC(void,CSurf_ScrubAmt)(double amt);

REAPERAPI_DECLFUNC(void,CSurf_SetAutoMode)(int mode, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetPlayState)(bool play, bool pause, bool rec, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetRepeatState)(bool rep, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfaceMute)(MediaTrack* trackid, bool mute, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfacePan)(MediaTrack* trackid, double pan, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfaceRecArm)(MediaTrack* trackid, bool recarm, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfaceSelected)(MediaTrack* trackid, bool selected, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfaceSolo)(MediaTrack* trackid, bool solo, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetSurfaceVolume)(MediaTrack* trackid, double volume, IReaperControlSurface* ignoresurf);

REAPERAPI_DECLFUNC(void,CSurf_SetTrackListChange)();

REAPERAPI_DECLFUNC(MediaTrack*,CSurf_TrackFromID)(int idx, bool mcpView);

REAPERAPI_DECLFUNC(int,CSurf_TrackToID)(MediaTrack* track, bool mcpView);

REAPERAPI_DECLFUNC(double,DB2SLIDER)(double x);

// Delete the specific shortcut for the given command ID.
// See CountActionShortcuts, GetActionShortcutDesc, DoActionShortcutDialog.
REAPERAPI_DECLFUNC(bool,DeleteActionShortcut)(KbdSectionInfo* section, int cmdID, int shortcutidx);

// Delete the extended state value for a specific section and key. persist=true means the value should remain deleted the next time REAPER is opened. See SetExtState, GetExtState, HasExtState.
REAPERAPI_DECLFUNC(void,DeleteExtState)(const char* section, const char* key, bool persist);

// Delete a marker.  proj==NULL for the active project.
REAPERAPI_DECLFUNC(bool,DeleteProjectMarker)(ReaProject* proj, int markrgnindexnumber, bool isrgn);

// Differs from DeleteProjectMarker only in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker4).
REAPERAPI_DECLFUNC(bool,DeleteProjectMarkerByIndex)(ReaProject* proj, int markrgnidx);

// Deletes one or more stretch markers. Returns number of stretch markers deleted.
REAPERAPI_DECLFUNC(int,DeleteTakeStretchMarkers)(MediaItem_Take* take, int idx, const int* countInOptional);

// deletes a track
REAPERAPI_DECLFUNC(void,DeleteTrack)(MediaTrack* tr);

REAPERAPI_DECLFUNC(bool,DeleteTrackMediaItem)(MediaTrack* tr, MediaItem* it);

// Destroy an audio accessor. Must only call from the main thread. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples. 
REAPERAPI_DECLFUNC(void,DestroyAudioAccessor)(AudioAccessor* accessor);

// See CreateLocalOscHandler, SendLocalOscMessage.
REAPERAPI_DECLFUNC(void,DestroyLocalOscHandler)(void* local_osc_handler);

// Open the action shortcut dialog to edit or add a shortcut for the given command ID. If (shortcutidx >= 0 && shortcutidx < CountActionShortcuts()), that specific shortcut will be replaced, otherwise a new shortcut will be added.
// See CountActionShortcuts, GetActionShortcutDesc, DeleteActionShortcut.
REAPERAPI_DECLFUNC(bool,DoActionShortcutDialog)(HWND hwnd, KbdSectionInfo* section, int cmdID, int shortcutidx);

// updates preference for docker window ident_str to be in dock whichDock on next open
REAPERAPI_DECLFUNC(void,Dock_UpdateDockID)(const char* ident_str, int whichDock);

// returns dock index that contains hwnd, or -1
REAPERAPI_DECLFUNC(int,DockIsChildOfDock)(HWND hwnd, bool* isFloatingDockerOut);

REAPERAPI_DECLFUNC(void,DockWindowActivate)(HWND hwnd);

REAPERAPI_DECLFUNC(void,DockWindowAdd)(HWND hwnd, const char* name, int pos, bool allowShow);

REAPERAPI_DECLFUNC(void,DockWindowAddEx)(HWND hwnd, const char* name, const char* identstr, bool allowShow);

REAPERAPI_DECLFUNC(void,DockWindowRefresh)();

REAPERAPI_DECLFUNC(void,DockWindowRefreshForHWND)(HWND hwnd);

REAPERAPI_DECLFUNC(void,DockWindowRemove)(HWND hwnd);

// Populate destmenu with all the entries and submenus found in srcmenu
REAPERAPI_DECLFUNC(bool,DuplicateCustomizableMenu)(void* srcmenu, void* destmenu);

// call with a saved window rect for your window and it'll correct any positioning info.
REAPERAPI_DECLFUNC(void,EnsureNotCompletelyOffscreen)(RECT* rOut);

// Start querying modes at 0, returns FALSE when no more modes possible, sets strOut to NULL if a mode is currently unsupported
REAPERAPI_DECLFUNC(bool,EnumPitchShiftModes)(int mode, const char** strOut);

// Returns submode name, or NULL
REAPERAPI_DECLFUNC(const char*,EnumPitchShiftSubModes)(int mode, int submode);

REAPERAPI_DECLFUNC(int,EnumProjectMarkers)(int idx, bool* isrgnOut, double* posOut, double* rgnendOut, const char** nameOut, int* markrgnindexnumberOut);

REAPERAPI_DECLFUNC(int,EnumProjectMarkers2)(ReaProject* proj, int idx, bool* isrgnOut, double* posOut, double* rgnendOut, const char** nameOut, int* markrgnindexnumberOut);

REAPERAPI_DECLFUNC(int,EnumProjectMarkers3)(ReaProject* proj, int idx, bool* isrgnOut, double* posOut, double* rgnendOut, const char** nameOut, int* markrgnindexnumberOut, int* colorOut);

// idx=-1 for current project,projfn can be NULL if not interested in filename. use idx 0x40000000 for currently rendering project, if any.
REAPERAPI_DECLFUNC(ReaProject*,EnumProjects)(int idx, char* projfn, int projfn_sz);

// Enumerate which tracks will be rendered within this region when using the region render matrix. When called with rendertrack==0, the function returns the first track that will be rendered (which may be the master track); rendertrack==1 will return the next track rendered, and so on. The function returns NULL when there are no more tracks that will be rendered within this region.
REAPERAPI_DECLFUNC(MediaTrack*,EnumRegionRenderMatrix)(ReaProject* proj, int regionindex, int rendertrack);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECLFUNC(bool,EnumTrackMIDIProgramNames)(int track, int programNumber, char* programName, int programName_sz);

// returns false if there are no plugins on the track that support MIDI programs,or if all programs have been enumerated
REAPERAPI_DECLFUNC(bool,EnumTrackMIDIProgramNamesEx)(ReaProject* proj, MediaTrack* track, int programNumber, char* programName, int programName_sz);

// returns true if path points to a valid, readable file
REAPERAPI_DECLFUNC(bool,file_exists)(const char* path);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECLFUNC(void,format_timestr)(double tpos, char* buf, int buf_sz);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
// offset is start of where the length will be calculated from
REAPERAPI_DECLFUNC(void,format_timestr_len)(double tpos, char* buf, int buf_sz, double offset, int modeoverride);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECLFUNC(void,format_timestr_pos)(double tpos, char* buf, int buf_sz, int modeoverride);

// free heap memory returned from a Reaper API function
REAPERAPI_DECLFUNC(void,FreeHeapPtr)(void* ptr);

REAPERAPI_DECLFUNC(void,genGuid)(GUID* g);

REAPERAPI_DECLFUNC(void*,get_config_var)(const char* name, int* szOut);

REAPERAPI_DECLFUNC(const char*,get_ini_file)();

REAPERAPI_DECLFUNC(void*,get_midi_config_var)(const char* name, int* szOut);

// Get the text description of a specific shortcut for the given command ID.
// See CountActionShortcuts,DeleteActionShortcut,DoActionShortcutDialog.
REAPERAPI_DECLFUNC(bool,GetActionShortcutDesc)(KbdSectionInfo* section, int cmdID, int shortcutidx, char* desc, int desclen);

// get the active take in this item
REAPERAPI_DECLFUNC(MediaItem_Take*,GetActiveTake)(MediaItem* item);

REAPERAPI_DECLFUNC(const char*,GetAppVersion)();

// Get the end time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorSamples.
REAPERAPI_DECLFUNC(double,GetAudioAccessorEndTime)(AudioAccessor* accessor);

// Get a short hash string (128 chars or less) that will change only if the underlying samples change.  See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorStartTime, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECLFUNC(void,GetAudioAccessorHash)(AudioAccessor* accessor, char* hashNeed128);

// Get a block of samples from the audio accessor. Samples are extracted immediately pre-FX, and returned interleaved (first sample of first channel, first sample of second channel...). Returns 0 if no audio, 1 if audio, -1 on error. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorStartTime, GetAudioAccessorEndTime.
REAPERAPI_DECLFUNC(int,GetAudioAccessorSamples)(AudioAccessor* accessor, int samplerate, int numchannels, double starttime_sec, int numsamplesperchannel, double* samplebuffer);

// Get the start time of the audio that can be returned from this accessor. See CreateTakeAudioAccessor, CreateTrackAudioAccessor, DestroyAudioAccessor, GetAudioAccessorHash, GetAudioAccessorEndTime, GetAudioAccessorSamples.
REAPERAPI_DECLFUNC(double,GetAudioAccessorStartTime)(AudioAccessor* accessor);

// deprecated?
REAPERAPI_DECLFUNC(INT_PTR,GetColorTheme)(int idx, int defval);

// returns the whole color theme (icontheme.h) and the size
REAPERAPI_DECLFUNC(void*,GetColorThemeStruct)(int* szOut);

// gets the dock ID desired by ident_str, if any
REAPERAPI_DECLFUNC(int,GetConfigWantsDock)(const char* ident_str);

// gets context menus. submenu 0:trackctl, 1:mediaitems, 2:ruler, 3:empty track area
REAPERAPI_DECLFUNC(HMENU,GetContextMenu)(int idx);

// returns current project if in load/save (usually only used from project_config_extension_t)
REAPERAPI_DECLFUNC(ReaProject*,GetCurrentProjectInLoadSave)();

// return the current cursor context: 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown
REAPERAPI_DECLFUNC(int,GetCursorContext)();

// 0 if track panels, 1 if items, 2 if envelopes, otherwise unknown (unlikely when want_last_valid is true)
REAPERAPI_DECLFUNC(int,GetCursorContext2)(bool want_last_valid);

// edit cursor position
REAPERAPI_DECLFUNC(double,GetCursorPosition)();

// edit cursor position
REAPERAPI_DECLFUNC(double,GetCursorPositionEx)(ReaProject* proj);

// returns the custom take, item, or track color that is used (according to the user preference) to color the media item.  The color is returned as 0x01RRGGBB, so a return of zero means "no color", not black.
REAPERAPI_DECLFUNC(int,GetDisplayedMediaItemColor)(MediaItem* item);

// returns the custom take, item, or track color that is used (according to the user preference) to color the media item.  The color is returned as 0x01RRGGBB, so a return of zero means "no color", not black.
REAPERAPI_DECLFUNC(int,GetDisplayedMediaItemColor2)(MediaItem* item, MediaItem_Take* take);

REAPERAPI_DECLFUNC(bool,GetEnvelopeName)(TrackEnvelope* env, char* buf, int buf_sz);

// returns path of REAPER.exe (not including EXE), i.e. C:\Program Files\REAPER
REAPERAPI_DECLFUNC(const char*,GetExePath)();

// Get the extended state value for a specific section and key. See SetExtState, DeleteExtState, HasExtState.
REAPERAPI_DECLFUNC(const char*,GetExtState)(const char* section, const char* key);

// Returns 1 if a track FX window has focus, 2 if an item FX window has focus, 0 if no FX window has focus. tracknumber==0 means the master track, 1 means track 1, etc. itemnumber and fxnumber are zero-based. See GetLastTouchedFX.
REAPERAPI_DECLFUNC(int,GetFocusedFX)(int* tracknumberOut, int* itemnumberOut, int* fxnumberOut);

// returns free disk space in megabytes, pathIdx 0 for normal, 1 for alternate.
REAPERAPI_DECLFUNC(int,GetFreeDiskSpaceForRecordPath)(ReaProject* proj, int pathidx);

// return -1=no override, 0=trim/read, 1=read, 2=touch, 3=write, 4=latch, 5=bypass
REAPERAPI_DECLFUNC(int,GetGlobalAutomationOverride)();

// returns pixels/second
REAPERAPI_DECLFUNC(double,GetHZoomLevel)();

// returns a named icontheme entry
REAPERAPI_DECLFUNC(void*,GetIconThemePointer)(const char* name);

// returns a pointer to the icon theme (icontheme.h) and the size of that struct
REAPERAPI_DECLFUNC(void*,GetIconThemeStruct)(int* szOut);

REAPERAPI_DECLFUNC(const char*,GetInputChannelName)(int channelIndex);

// Gets the audio device input/output latency in samples
REAPERAPI_DECLFUNC(void,GetInputOutputLatency)(int* inputlatencyOut,  int* outputLatencyOut);

// returns time of relevant edit, set which_item to the pcm_source (if applicable), flags (if specified) will be set to 1 for edge resizing, 2 for fade change, 4 for item move
REAPERAPI_DECLFUNC(double,GetItemEditingTime2)(PCM_source** which_itemOut, int* flagsOut);

REAPERAPI_DECLFUNC(void*,GetItemProjectContext)(MediaItem* item);

// Get the last project marker before time, and/or the project region that includes time. markeridx and regionidx are returned not necessarily as the displayed marker/region index, but as the index that can be passed to EnumProjectMarkers. Either or both of markeridx and regionidx may be NULL. See EnumProjectMarkers.
REAPERAPI_DECLFUNC(void,GetLastMarkerAndCurRegion)(ReaProject* proj, double time, int* markeridxOut, int* regionidxOut);

// Returns true if the last touched FX parameter is valid, false otherwise. tracknumber==0 means the master track, 1 means track 1, etc. fxnumber and paramnumber are zero-based. See GetFocusedFX.
REAPERAPI_DECLFUNC(bool,GetLastTouchedFX)(int* tracknumberOut, int* fxnumberOut, int* paramnumberOut);

REAPERAPI_DECLFUNC(MediaTrack*,GetLastTouchedTrack)();

REAPERAPI_DECLFUNC(HWND,GetMainHwnd)();

// &1=master mute,&2=master solo. This is deprecated as you can just query the master track as well.
REAPERAPI_DECLFUNC(int,GetMasterMuteSoloFlags)();

REAPERAPI_DECLFUNC(MediaTrack*,GetMasterTrack)(ReaProject* proj);

// returns &1 if the master track is visible in the TCP, &2 if visible in the mixer. See SetMasterTrackVisibility.
REAPERAPI_DECLFUNC(int,GetMasterTrackVisibility)();

// returns max dev for midi inputs/outputs
REAPERAPI_DECLFUNC(int,GetMaxMidiInputs)();

REAPERAPI_DECLFUNC(int,GetMaxMidiOutputs)();

// get an item from a project by item count (zero-based) (proj=0 for active project)
REAPERAPI_DECLFUNC(MediaItem*,GetMediaItem)(ReaProject* proj, int itemidx);

// Get parent track of media item
REAPERAPI_DECLFUNC(MediaTrack*,GetMediaItem_Track)(MediaItem* item);

// Get media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECLFUNC(double,GetMediaItemInfo_Value)(MediaItem* item, const char* parmname);

REAPERAPI_DECLFUNC(int,GetMediaItemNumTakes)(MediaItem* item);

REAPERAPI_DECLFUNC(MediaItem_Take*,GetMediaItemTake)(MediaItem* item, int tk);

// Get parent item of media item take
REAPERAPI_DECLFUNC(MediaItem*,GetMediaItemTake_Item)(MediaItem_Take* take);

// Get media source of media item take
REAPERAPI_DECLFUNC(PCM_source*,GetMediaItemTake_Source)(MediaItem_Take* take);

// Get parent track of media item take
REAPERAPI_DECLFUNC(MediaTrack*,GetMediaItemTake_Track)(MediaItem_Take* take);

REAPERAPI_DECLFUNC(MediaItem_Take*,GetMediaItemTakeByGUID)(ReaProject* project, const GUID*  guid);

// Get media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECLFUNC(double,GetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname);

REAPERAPI_DECLFUNC(MediaTrack*,GetMediaItemTrack)(MediaItem* item);

// Copies the media source filename to typebuf. Note that in-project MIDI media sources have no associated filename.
REAPERAPI_DECLFUNC(void,GetMediaSourceFileName)(PCM_source* source, char* filenamebuf, int filenamebuf_sz);

// Returns the number of channels in the source media.
REAPERAPI_DECLFUNC(int,GetMediaSourceNumChannels)(PCM_source* source);

// Returns the sample rate. MIDI source media will return zero.
REAPERAPI_DECLFUNC(int,GetMediaSourceSampleRate)(PCM_source* source);

// copies the media source type ("WAV", "MIDI", etc) to typebuf
REAPERAPI_DECLFUNC(void,GetMediaSourceType)(PCM_source* source, char* typebuf, int typebuf_sz);

// Get track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECLFUNC(double,GetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname);

REAPERAPI_DECLFUNC(midi_Input*,GetMidiInput)(int idx);

// returns true if device present
REAPERAPI_DECLFUNC(bool,GetMIDIInputName)(int dev, char* nameout, int nameout_sz);

REAPERAPI_DECLFUNC(midi_Output*,GetMidiOutput)(int idx);

// returns true if device present
REAPERAPI_DECLFUNC(bool,GetMIDIOutputName)(int dev, char* nameout, int nameout_sz);

// Get the leftmost track visible in the mixer
REAPERAPI_DECLFUNC(MediaTrack*,GetMixerScroll)();

// Get the current mouse modifier assignment for a specific modifier key assignment, in a specific context.
// action will be filled in with the command ID number for a built-in mouse modifier
// or built-in REAPER command ID, or the custom action ID string.
// See SetMouseModifier for more information.
REAPERAPI_DECLFUNC(void,GetMouseModifier)(const char* context, int modifier_flag, char* action, int action_sz);

// Return number of normal audio hardware inputs available
REAPERAPI_DECLFUNC(int,GetNumAudioInputs)();

// Return number of normal audio hardware outputs available
REAPERAPI_DECLFUNC(int,GetNumAudioOutputs)();

// returns max number of real midi hardware inputs
REAPERAPI_DECLFUNC(int,GetNumMIDIInputs)();

// returns max number of real midi hardware outputs
REAPERAPI_DECLFUNC(int,GetNumMIDIOutputs)();

REAPERAPI_DECLFUNC(int,GetNumTracks)();

REAPERAPI_DECLFUNC(const char*,GetOutputChannelName)(int channelIndex);

// returns output latency in seconds
REAPERAPI_DECLFUNC(double,GetOutputLatency)();

REAPERAPI_DECLFUNC(MediaTrack*,GetParentTrack)(MediaTrack* track);

// get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)
REAPERAPI_DECLFUNC(void,GetPeakFileName)(const char* fn, char* buf, int buf_sz);

// get the peak file name for a given file (can be either filename.reapeaks,or a hashed filename in another path)
REAPERAPI_DECLFUNC(void,GetPeakFileNameEx)(const char* fn, char* buf, int buf_sz, bool forWrite);

// Like GetPeakFileNameEx, but you can specify peaksfileextension such as ".reapeaks"
REAPERAPI_DECLFUNC(void,GetPeakFileNameEx2)(const char* fn, char* buf, int buf_sz, bool forWrite, const char* peaksfileextension);

// see note in reaper_plugin.h about PCM_source_peaktransfer_t::samplerate
REAPERAPI_DECLFUNC(void*,GetPeaksBitmap)(PCM_source_peaktransfer_t* pks, double maxamp, int w, int h, LICE_IBitmap* bmp);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECLFUNC(double,GetPlayPosition)();

// returns position of next audio block being processed
REAPERAPI_DECLFUNC(double,GetPlayPosition2)();

// returns position of next audio block being processed
REAPERAPI_DECLFUNC(double,GetPlayPosition2Ex)(ReaProject* proj);

// returns latency-compensated actual-what-you-hear position
REAPERAPI_DECLFUNC(double,GetPlayPositionEx)(ReaProject* proj);

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECLFUNC(int,GetPlayState)();

// &1=playing,&2=pause,&=4 is recording
REAPERAPI_DECLFUNC(int,GetPlayStateEx)(ReaProject* proj);

// Gets user configured preferred disk read mode. mode/nb/bs are all parameters that should be passed to WDL_FileRead, see for more information.
REAPERAPI_DECLFUNC(void,GetPreferredDiskReadMode)(int* mode, int* nb, int* bs);

// Gets user configured preferred disk read mode for use when building peaks. mode/nb/bs are all parameters that should be passed to WDL_FileRead, see for more information.
REAPERAPI_DECLFUNC(void,GetPreferredDiskReadModePeak)(int* mode, int* nb, int* bs);

// Gets user configured preferred disk write mode. nb will receive two values, the initial and maximum write buffer counts. mode/nb/bs are all parameters that should be passed to WDL_FileWrite, see for more information. 
REAPERAPI_DECLFUNC(void,GetPreferredDiskWriteMode)(int* mode, int* nb, int* bs);

REAPERAPI_DECLFUNC(void,GetProjectPath)(char* buf, int buf_sz);

REAPERAPI_DECLFUNC(void,GetProjectPathEx)(ReaProject* proj, char* buf, int buf_sz);

// returns an integer that changes when the project state changes
REAPERAPI_DECLFUNC(int,GetProjectStateChangeCount)(ReaProject* proj);

// deprecated
REAPERAPI_DECLFUNC(void,GetProjectTimeSignature)(double* bpmOut, double* bpiOut);

// Gets basic time signature (beats per minute, numerator of time signature in bpi)
// this does not reflect tempo envelopes but is purely what is set in the project settings.
REAPERAPI_DECLFUNC(void,GetProjectTimeSignature2)(ReaProject* proj, double* bpmOut, double* bpiOut);

// returns path where ini files are stored, other things are in subdirectories.
REAPERAPI_DECLFUNC(const char*,GetResourcePath)();

// get the currently selected envelope, returns 0 if no envelope is selected
REAPERAPI_DECLFUNC(TrackEnvelope*,GetSelectedEnvelope)(ReaProject* proj);

// get a selected item by selected item count (zero-based) (proj=0 for active project)
REAPERAPI_DECLFUNC(MediaItem*,GetSelectedMediaItem)(ReaProject* proj, int selitem);

// get a selected track from a project by selected track count (zero-based) (proj=0 for active project)
REAPERAPI_DECLFUNC(MediaTrack*,GetSelectedTrack)(ReaProject* proj, int seltrackidx);

// get the currently selected track envelope, returns 0 if no envelope is selected
REAPERAPI_DECLFUNC(TrackEnvelope*,GetSelectedTrackEnvelope)(ReaProject* proj);

REAPERAPI_DECLFUNC(void,GetSet_ArrangeView2)(ReaProject* proj, bool isSet, int screen_x_start, int screen_x_end, double* start_timeOut, double* end_timeOut);

REAPERAPI_DECLFUNC(void,GetSet_LoopTimeRange)(bool isSet, bool isLoop, double* startOut, double* endOut, bool allowautoseek);

REAPERAPI_DECLFUNC(void,GetSet_LoopTimeRange2)(ReaProject* proj, bool isSet, bool isLoop, double* startOut, double* endOut, bool allowautoseek);

// get or set the state of an envelope as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetEnvelopeState)(TrackEnvelope* env, char* str, int str_sz);

// get or set the state of an envelope as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetEnvelopeState2)(TrackEnvelope* env, char* str, int str_sz, bool isundo);

// get or set the state of a media item as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetItemState)(MediaItem* item, char* str, int str_sz);

// get or set the state of a media item as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetItemState2)(MediaItem* item, char* str, int str_sz, bool isundo);

// P_TRACK : MediaTrack * (read only)
// P_NOTES : char * : item note text (do not write to returned pointer, use setNewValue to update)
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECLFUNC(void*,GetSetMediaItemInfo)(MediaItem* item, const char* parmname, void* setNewValue);

// P_TRACK : pointer to MediaTrack (read-only)
// P_ITEM : pointer to MediaItem (read-only)
// P_SOURCE : PCM_source *. Note that if setting this, you should first retrieve the old source, set the new, THEN delete the old.
// GUID : GUID * : 16-byte GUID, can query or update
// P_NAME : char * to take name
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECLFUNC(void*,GetSetMediaItemTakeInfo)(MediaItem_Take* tk, const char* parmname, void* setNewValue);

// P_NAME : char * to take name
REAPERAPI_DECLFUNC(bool,GetSetMediaItemTakeInfo_String)(MediaItem_Take* tk, const char* parmname, char* stringNeedBig, bool setnewvalue);

// Get or set track attributes.
// P_PARTRACK : MediaTrack * : parent track (read-only)
// GUID : GUID * : 16-byte GUID, can query or update (do not use on master though)
// P_NAME : char * : track name (on master returns NULL)
// 
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECLFUNC(void*,GetSetMediaTrackInfo)(MediaTrack* tr, const char* parmname, void* setNewVanue);

// Get or set track string attributes.
// P_NAME : char * : track name (on master returns NULL)
// 
REAPERAPI_DECLFUNC(bool,GetSetMediaTrackInfo_String)(MediaTrack* tr, const char* parmname, char* stringNeedBig, bool setnewvalue);

// get or set the state of a {track,item,envelope} as an xml/rpp chunk
// str="" to get the chunk string returned (must call FreeHeapPtr when done)
// supply str to set the state (returns zero)
REAPERAPI_DECLFUNC(char*,GetSetObjectState)(void* obj, const char* str);

// get or set the state of a {track,item,envelope} as an xml/rpp chunk
// str="" to get the chunk string returned (must call FreeHeapPtr when done)
// supply str to set the state (returns zero)
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently
REAPERAPI_DECLFUNC(char*,GetSetObjectState2)(void* obj, const char* str, bool isundo);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECLFUNC(int,GetSetRepeat)(int val);

// -1 == query,0=clear,1=set,>1=toggle . returns new value
REAPERAPI_DECLFUNC(int,GetSetRepeatEx)(ReaProject* proj, int val);

// Get or set the filename for storage of various track MIDI characteristics. 0=MIDI colormap image file, 1=MIDI bank/program select file, 2=MIDI text string file. If fn != NULL, a new track MIDI storage file will be set; otherwise the existing track MIDI storage file will be returned. 
REAPERAPI_DECLFUNC(const char*,GetSetTrackMIDISupportFile)(ReaProject* proj, MediaTrack* track, int which, const char* filename);

// category is <0 for receives, 0=sends, >0 for hardware outputs
// sendidx is 0..n (NULL on any required parameter to stop)
// parameter names:
// P_DESTTRACK : read only, returns MediaTrack *, destination track, only applies for sends/recvs
// P_SRCTRACK : read only, returns MediaTrack *, source track, only applies for sends/recvs
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_MUTE : returns bool *, read/write
// B_PHASE : returns bool *, read/write, true to flip phase
// B_MONO : returns bool *, read/write
// D_VOL : returns double *, read/write, 1.0 = +0dB etc
// D_PAN : returns double *, read/write, -1..+1
// D_PANLAW : returns double *,read/write, 1.0=+0.0db, 0.5=-6dB, -1.0 = projdef etc
// I_SENDMODE : returns int *, read/write, 0=post-fader, 1=pre-fx, 2=post-fx(depr), 3=post-fx
// I_SRCCHAN : returns int *, read/write, index,&1024=mono, -1 for none
// I_DSTCHAN : returns int *, read/write, index, &1024=mono, otherwise stereo pair, hwout:&512=rearoute
// I_MIDIFLAGS : returns int *, read/write, low 5 bits=source channel 0=all, 1-16, next 5 bits=dest channel, 0=orig, 1-16=chan
REAPERAPI_DECLFUNC(void*,GetSetTrackSendInfo)(MediaTrack* tr, int category, int sendidx, const char* parmname, void* setNewValue);

// get or set the state of a track as an xml/rpp chunk.
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetTrackState)(MediaTrack* track, char* str, int str_sz);

// get or set the state of a track as an xml/rpp chunk.
// set isundo if the state will be used for undo purposes (which may allow REAPER to get the state more efficiently)
// supply str="" to get the state returned in str.
// the returned state string is limited to maxlen characters.
// supply str as an xml/rpp string to set the object state.
// returns true on success.
REAPERAPI_DECLFUNC(bool,GetSetTrackState2)(MediaTrack* track, char* str, int str_sz, bool isundo);

REAPERAPI_DECLFUNC(ReaProject*,GetSubProjectFromSource)(PCM_source* src);

// get a take from an item by take count (zero-based)
REAPERAPI_DECLFUNC(MediaItem_Take*,GetTake)(MediaItem* item, int takeidx);

REAPERAPI_DECLFUNC(TrackEnvelope*,GetTakeEnvelopeByName)(MediaItem_Take* take, const char* envname);

// returns NULL if the take is not valid
REAPERAPI_DECLFUNC(const char*,GetTakeName)(MediaItem_Take* take);

// Returns number of stretch markers in take
REAPERAPI_DECLFUNC(int,GetTakeNumStretchMarkers)(MediaItem_Take* take);

// Gets information on a stretch marker, idx is 0..n. Returns false if stretch marker not valid. posOut will be set to position in item, srcposOutOptional will be set to source media position. Returns index. if input index is -1, next marker is found using position (or source position if position is -1). If position/source position are used to find marker position, their values are not updated.
REAPERAPI_DECLFUNC(int,GetTakeStretchMarker)(MediaItem_Take* take, int idx, double* posOut, double* srcposOutOptional);

// Get information about a specific FX parameter knob (see CountTCPFXParms).
REAPERAPI_DECLFUNC(bool,GetTCPFXParm)(ReaProject* project, MediaTrack* track, int index, int* fxindexOut, int* parmidxOut);

// finds the playrate and target length to insert this item stretched to a round power-of-2 number of bars, between 1/8 and 256
REAPERAPI_DECLFUNC(bool,GetTempoMatchPlayRate)(PCM_source* source, double srcscale, double position, double mult, double* rateOut, double* targetlenOut);

// Get information about a tempo/time signature marker. See CountTempoTimeSigMarkers, SetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECLFUNC(bool,GetTempoTimeSigMarker)(ReaProject* proj, int ptidx, double* timeposOut, int* measureposOut, double* beatposOut, double* bpmOut, int* timesig_numOut, int* timesig_denomOut, bool* lineartempoOut);

REAPERAPI_DECLFUNC(int,GetToggleCommandState)(int command_id);

// For the main action context, the MIDI editor, or the media explorer, returns the toggle state of the action. 0=off, 1=on, -1=NA because the action does not have on/off states.  For the MIDI editor, the action state for the most recently focused window will be returned.
REAPERAPI_DECLFUNC(int,GetToggleCommandState2)(KbdSectionInfo* section, int cmdID);

REAPERAPI_DECLFUNC(int,GetToggleCommandStateThroughHooks)(KbdSectionInfo* sec, int command_id);

// gets a tooltip window,in case you want to ask it for font information. Can return NULL.
REAPERAPI_DECLFUNC(HWND,GetTooltipWindow)();

// get a track from a project by track count (zero-based) (proj=0 for active project)
REAPERAPI_DECLFUNC(MediaTrack*,GetTrack)(ReaProject* proj, int trackidx);

// return the track mode, regardless of global override
REAPERAPI_DECLFUNC(int,GetTrackAutomationMode)(MediaTrack* tr);

// Returns the track color, as 0x01RRGGBB. Black is returned as 0x01000000, no color setting is returned as 0.
REAPERAPI_DECLFUNC(int,GetTrackColor)(MediaTrack* track);

REAPERAPI_DECLFUNC(int,GetTrackDepth)(MediaTrack* track);

REAPERAPI_DECLFUNC(TrackEnvelope*,GetTrackEnvelope)(MediaTrack* track, int envidx);

REAPERAPI_DECLFUNC(TrackEnvelope*,GetTrackEnvelopeByName)(MediaTrack* track, const char* envname);

REAPERAPI_DECLFUNC(GUID*,GetTrackGUID)(MediaTrack* tr);

// gets track info (returns name).
// track index, -1=master, 0..n, or cast a MediaTrack* to int
// if flags is non-NULL, will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECLFUNC(const char*,GetTrackInfo)(INT_PTR track, int* flags);

REAPERAPI_DECLFUNC(MediaItem*,GetTrackMediaItem)(MediaTrack* tr, int itemidx);

REAPERAPI_DECLFUNC(const char*,GetTrackMIDINoteName)(int track, int note, int chan);

REAPERAPI_DECLFUNC(const char*,GetTrackMIDINoteNameEx)(ReaProject* proj, MediaTrack* track, int note, int chan);

REAPERAPI_DECLFUNC(void,GetTrackMIDINoteRange)(ReaProject* proj, MediaTrack* track, int* note_loOut, int* note_hiOut);

REAPERAPI_DECLFUNC(int,GetTrackNumMediaItems)(MediaTrack* tr);

// returns number of sends/receives/hardware outputs - category is <0 for receives, 0=sends, >0 for hardware outputs
REAPERAPI_DECLFUNC(int,GetTrackNumSends)(MediaTrack* tr, int category);

REAPERAPI_DECLFUNC(bool,GetTrackReceiveName)(MediaTrack* track, int recv_index, char* buf, int buf_sz);

REAPERAPI_DECLFUNC(bool,GetTrackReceiveUIMute)(MediaTrack* track, int recv_index, bool* muteOut);

REAPERAPI_DECLFUNC(bool,GetTrackReceiveUIVolPan)(MediaTrack* track, int recv_index, double* volumeOut, double* panOut);

REAPERAPI_DECLFUNC(bool,GetTrackSendName)(MediaTrack* track, int send_index, char* buf, int buf_sz);

REAPERAPI_DECLFUNC(bool,GetTrackSendUIMute)(MediaTrack* track, int send_index, bool* muteOut);

REAPERAPI_DECLFUNC(bool,GetTrackSendUIVolPan)(MediaTrack* track, int send_index, double* volumeOut, double* panOut);

// Gets track state, returns track name.
// flags will be set to:
// &1=folder
// &2=selected
// &4=has fx enabled
// &8=muted
// &16=soloed
// &32=SIP'd (with &16)
// &64=rec armed
REAPERAPI_DECLFUNC(const char*,GetTrackState)(MediaTrack* track, int* flagsOut);

REAPERAPI_DECLFUNC(bool,GetTrackUIMute)(MediaTrack* track, bool* muteOut);

REAPERAPI_DECLFUNC(bool,GetTrackUIPan)(MediaTrack* track, double* pan1Out, double* pan2Out, int* panmodeOut);

REAPERAPI_DECLFUNC(bool,GetTrackUIVolPan)(MediaTrack* track, double* volumeOut, double* panOut);

// returns true if the user selected a valid file, false if the user canceled the dialog
REAPERAPI_DECLFUNC(bool,GetUserFileNameForRead)(char* filenameNeed4096, const char* title, const char* defext);

// Get values from the user.
// If a caption begins with *, for example "*password", the edit field will not display the input text.
// Values are returned as a comma-separated string. Returns false if the user canceled the dialog.
REAPERAPI_DECLFUNC(bool,GetUserInputs)(const char* title, int num_inputs, const char* captions_csv, char* retvals_csv, int retvals_csv_sz);

// Go to marker. If use_timeline_order==true, marker_index 1 refers to the first marker on the timeline.  If use_timeline_order==false, marker_index 1 refers to the first marker with the user-editable index of 1.
REAPERAPI_DECLFUNC(void,GoToMarker)(ReaProject* proj, int marker_index, bool use_timeline_order);

// Seek to region after current region finishes playing (smooth seek). If use_timeline_order==true, region_index 1 refers to the first region on the timeline.  If use_timeline_order==false, region_index 1 refers to the first region with the user-editable index of 1.
REAPERAPI_DECLFUNC(void,GoToRegion)(ReaProject* proj, int region_index, bool use_timeline_order);

// Runs the system color chooser dialog.  Returns 0 if the user cancels the dialog.
REAPERAPI_DECLFUNC(int,GR_SelectColor)(HWND hwnd, int* colorOut);

// this is just like win32 GetSysColor() but can have overrides.
REAPERAPI_DECLFUNC(int,GSC_mainwnd)(int t);

// dest should be at least 64 chars long to be safe
REAPERAPI_DECLFUNC(void,guidToString)(const GUID* g, char* destNeed64);

// Returns true if there exists an extended state value for a specific section and key. See SetExtState, GetExtState, DeleteExtState.
REAPERAPI_DECLFUNC(bool,HasExtState)(const char* section, const char* key);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECLFUNC(const char*,HasTrackMIDIPrograms)(int track);

// returns name of track plugin that is supplying MIDI programs,or NULL if there is none
REAPERAPI_DECLFUNC(const char*,HasTrackMIDIProgramsEx)(ReaProject* proj, MediaTrack* track);

REAPERAPI_DECLFUNC(void,Help_Set)(const char* helpstring, bool is_temporary_help);

REAPERAPI_DECLFUNC(void,HiresPeaksFromSource)(PCM_source* src, PCM_source_peaktransfer_t* block);

REAPERAPI_DECLFUNC(void,image_resolve_fn)(const char* in, char* out, int out_sz);

// mode: 0=add to current track, 1=add new track, 3=add to selected items as takes, &4=stretch/loop to fit time sel, &8=try to match tempo 1x, &16=try to match tempo 0.5x, &32=try to match tempo 2x
REAPERAPI_DECLFUNC(int,InsertMedia)(const char* file, int mode);

REAPERAPI_DECLFUNC(int,InsertMediaSection)(const char* file, int mode, double startpct, double endpct, double pitchshift);

// inserts a track at idx,of course this will be clamped to 0..GetNumTracks(). wantDefaults=TRUE for default envelopes/FX,otherwise no enabled fx/env
REAPERAPI_DECLFUNC(void,InsertTrackAtIndex)(int idx, bool wantDefaults);

// are we in a realtime audio thread (between OnAudioBuffer calls,not in some worker/anticipative FX thread)? threadsafe
REAPERAPI_DECLFUNC(int,IsInRealTimeAudio)();

// get whether a take will be played (active take, unmuted, etc)
REAPERAPI_DECLFUNC(bool,IsItemTakeActiveForPlayback)(MediaItem* item, MediaItem_Take* take);

REAPERAPI_DECLFUNC(bool,IsMediaExtension)(const char* ext, bool wantOthers);

REAPERAPI_DECLFUNC(bool,IsMediaItemSelected)(MediaItem* item);

// Returns true if dealing with REAPER, returns false for ReaMote, etc
REAPERAPI_DECLFUNC(bool,IsREAPER)();

REAPERAPI_DECLFUNC(bool,IsTrackSelected)(MediaTrack* track);

// If mixer==true, returns true if the track is visible in the mixer.  If mixer==false, returns true if the track is visible in the track control panel.
REAPERAPI_DECLFUNC(bool,IsTrackVisible)(MediaTrack* track, bool mixer);

REAPERAPI_DECLFUNC(int,kbd_enumerateActions)(KbdSectionInfo* section, int idx, const char** nameOut);

REAPERAPI_DECLFUNC(void,kbd_formatKeyName)(ACCEL* ac, char* s);

REAPERAPI_DECLFUNC(void,kbd_getCommandName)(int cmd, char* s, KbdSectionInfo* section);

REAPERAPI_DECLFUNC(const char*,kbd_getTextFromCmd)(DWORD cmd, KbdSectionInfo* section);

// val/valhw are used for midi stuff.
// val=[0..127] and valhw=-1 (midi CC),
// valhw >=0 (midi pitch (valhw | val<<7)),
// relmode absolute (0) or 1/2/3 for relative adjust modes
REAPERAPI_DECLFUNC(int,KBD_OnMainActionEx)(int cmd, int val, int valhw, int relmode, HWND hwnd, ReaProject* proj);

// can be called from anywhere (threadsafe)
REAPERAPI_DECLFUNC(void,kbd_OnMidiEvent)(MIDI_event_t* evt, int dev_index);

// can be called from anywhere (threadsafe)
REAPERAPI_DECLFUNC(void,kbd_OnMidiList)(MIDI_eventlist* list, int dev_index);

REAPERAPI_DECLFUNC(void,kbd_ProcessActionsMenu)(HMENU menu, KbdSectionInfo* section);

REAPERAPI_DECLFUNC(bool,kbd_processMidiEventActionEx)(MIDI_event_t* evt, KbdSectionInfo* section, HWND hwndCtx);

REAPERAPI_DECLFUNC(void,kbd_reprocessMenu)(HMENU menu, KbdSectionInfo* section);

// actioncommandID may get modified
REAPERAPI_DECLFUNC(bool,kbd_RunCommandThroughHooks)(KbdSectionInfo* section, int* actionCommandID, int* val, int* valhw, int* relmode, HWND hwnd);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECLFUNC(int,kbd_translateAccelerator)(HWND hwnd, MSG* msg, KbdSectionInfo* section);

REAPERAPI_DECLFUNC(bool,kbd_translateMouse)(void* winmsg, unsigned char* midimsg);

#ifndef REAPERAPI_NO_LICE
REAPERAPI_DECLFUNC(void,LICE__Destroy)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(void,LICE__DestroyFont)(LICE_IFont* font);

REAPERAPI_DECLFUNC(int,LICE__DrawText)(LICE_IFont* font, LICE_IBitmap* bm, const char* str, int strcnt, RECT* rect, UINT dtFlags);

REAPERAPI_DECLFUNC(void*,LICE__GetBits)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(HDC,LICE__GetDC)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(int,LICE__GetHeight)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(int,LICE__GetRowSpan)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(int,LICE__GetWidth)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(bool,LICE__IsFlipped)(LICE_IBitmap* bm);

REAPERAPI_DECLFUNC(bool,LICE__resize)(LICE_IBitmap* bm, int w, int h);

REAPERAPI_DECLFUNC(LICE_pixel,LICE__SetBkColor)(LICE_IFont* font, LICE_pixel color);

// font must REMAIN valid,unless LICE_FONT_FLAG_PRECALCALL is set
REAPERAPI_DECLFUNC(void,LICE__SetFromHFont)(LICE_IFont* font, HFONT hfont, int flags);

REAPERAPI_DECLFUNC(LICE_pixel,LICE__SetTextColor)(LICE_IFont* font, LICE_pixel color);

REAPERAPI_DECLFUNC(void,LICE__SetTextCombineMode)(LICE_IFont* ifont, int mode, float alpha);

REAPERAPI_DECLFUNC(void,LICE_Arc)(LICE_IBitmap* dest, float cx, float cy, float r, float minAngle, float maxAngle, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(void,LICE_Blit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_Blur)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int srcx, int srcy, int srcw, int srch);

REAPERAPI_DECLFUNC(void,LICE_BorderedRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel bgcolor, LICE_pixel fgcolor, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_Circle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(void,LICE_Clear)(LICE_IBitmap* dest, LICE_pixel color);

REAPERAPI_DECLFUNC(void,LICE_ClearRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel mask, LICE_pixel orbits);

// Returns false if the line is entirely offscreen.
REAPERAPI_DECLFUNC(bool,LICE_ClipLine)(int* pX1Out, int* pY1Out, int* pX2Out, int* pY2Out, int xLo, int yLo, int xHi, int yHi);

REAPERAPI_DECLFUNC(void,LICE_Copy)(LICE_IBitmap* dest, LICE_IBitmap* src);

// create a new bitmap. this is like calling new LICE_MemBitmap (mode=0) or new LICE_SysBitmap (mode=1).
REAPERAPI_DECLFUNC(LICE_IBitmap*,LICE_CreateBitmap)(int mode, int w, int h);

REAPERAPI_DECLFUNC(LICE_IFont*,LICE_CreateFont)();

REAPERAPI_DECLFUNC(void,LICE_DrawChar)(LICE_IBitmap* bm, int x, int y, char c, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_DrawGlyph)(LICE_IBitmap* dest, int x, int y, LICE_pixel color, LICE_pixel_chan* alphas, int glyph_w, int glyph_h, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_DrawRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_DrawText)(LICE_IBitmap* bm, int x, int y, const char* string, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_FillCircle)(LICE_IBitmap* dest, float cx, float cy, float r, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(void,LICE_FillConvexPolygon)(LICE_IBitmap* dest, int* x, int* y, int npoints, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_FillRect)(LICE_IBitmap* dest, int x, int y, int w, int h, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_FillTrapezoid)(LICE_IBitmap* dest, int x1a, int x1b, int y1, int x2a, int x2b, int y2, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_FillTriangle)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, int x3, int y3, LICE_pixel color, float alpha, int mode);

REAPERAPI_DECLFUNC(LICE_pixel,LICE_GetPixel)(LICE_IBitmap* bm, int x, int y);

REAPERAPI_DECLFUNC(void,LICE_GradRect)(LICE_IBitmap* dest, int dstx, int dsty, int dstw, int dsth, float ir, float ig, float ib, float ia, float drdx, float dgdx, float dbdx, float dadx, float drdy, float dgdy, float dbdy, float dady, int mode);

REAPERAPI_DECLFUNC(void,LICE_Line)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(void,LICE_LineInt)(LICE_IBitmap* dest, int x1, int y1, int x2, int y2, LICE_pixel color, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(LICE_IBitmap*,LICE_LoadPNG)(const char* filename, LICE_IBitmap* bmp);

REAPERAPI_DECLFUNC(LICE_IBitmap*,LICE_LoadPNGFromResource)(HINSTANCE hInst, int resid, LICE_IBitmap* bmp);

REAPERAPI_DECLFUNC(void,LICE_MeasureText)(const char* string, int* w, int* h);

REAPERAPI_DECLFUNC(void,LICE_MultiplyAddRect)(LICE_IBitmap* dest, int x, int y, int w, int h, float rsc, float gsc, float bsc, float asc, float radd, float gadd, float badd, float aadd);

REAPERAPI_DECLFUNC(void,LICE_PutPixel)(LICE_IBitmap* bm, int x, int y, LICE_pixel color, float alpha, int mode);

// these coordinates are offset from the center of the image,in source pixel coordinates
REAPERAPI_DECLFUNC(void,LICE_RotatedBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float angle, bool cliptosourcerect, float alpha, int mode, float rotxcent, float rotycent);

REAPERAPI_DECLFUNC(void,LICE_RoundRect)(LICE_IBitmap* drawbm, float xpos, float ypos, float w, float h, int cornerradius, LICE_pixel col, float alpha, int mode, bool aa);

REAPERAPI_DECLFUNC(void,LICE_ScaledBlit)(LICE_IBitmap* dest, LICE_IBitmap* src, int dstx, int dsty, int dstw, int dsth, float srcx, float srcy, float srcw, float srch, float alpha, int mode);

REAPERAPI_DECLFUNC(void,LICE_SimpleFill)(LICE_IBitmap* dest, int x, int y, LICE_pixel newcolor, LICE_pixel comparemask, LICE_pixel keepmask);

#endif // !REAPERAPI_NO_LICE
// Move the loop selection left or right. Returns true if snap is enabled.
REAPERAPI_DECLFUNC(bool,Loop_OnArrow)(ReaProject* project, int direction);

REAPERAPI_DECLFUNC(void,Main_OnCommand)(int command, int flag);

REAPERAPI_DECLFUNC(void,Main_OnCommandEx)(int command, int flag, ReaProject* proj);

// opens a project. will prompt the user to save, etc.
// if you pass a .RTrackTemplate file then it adds that to the project instead.
REAPERAPI_DECLFUNC(void,Main_openProject)(const char* name);

REAPERAPI_DECLFUNC(void,Main_UpdateLoopInfo)(int ignoremask);

// marks project as dirty (needing save)
REAPERAPI_DECLFUNC(void,MarkProjectDirty)(ReaProject* proj);

// If track is supplied, item is ignored
REAPERAPI_DECLFUNC(void,MarkTrackItemsDirty)(MediaTrack* track, MediaItem* item);

REAPERAPI_DECLFUNC(double,Master_GetPlayRate)(ReaProject* project);

REAPERAPI_DECLFUNC(double,Master_GetPlayRateAtTime)(double time_s, ReaProject* proj);

REAPERAPI_DECLFUNC(double,Master_GetTempo)();

// Convert play rate to/from a value between 0 and 1, representing the position on the project playrate slider.
REAPERAPI_DECLFUNC(double,Master_NormalizePlayRate)(double playrate, bool isnormalized);

// Convert the tempo to/from a value between 0 and 1, representing bpm in the range of 40-296 bpm.
REAPERAPI_DECLFUNC(double,Master_NormalizeTempo)(double bpm, bool isnormalized);

// type 0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECLFUNC(int,MB)(const char* msg, const char* title, int type);

// Returns 1 if the track holds the item, 2 if the track is a folder containing the track that holds the item, etc.
REAPERAPI_DECLFUNC(int,MediaItemDescendsFromTrack)(MediaItem* item, MediaTrack* track);

// Count the number of notes, CC events, and text/sysex events in a given MIDI item.
REAPERAPI_DECLFUNC(int,MIDI_CountEvts)(MediaItem_Take* take, int* notecntOut, int* ccevtcntOut, int* textsyxevtcntOut);

// Delete a MIDI CC event.
REAPERAPI_DECLFUNC(bool,MIDI_DeleteCC)(MediaItem_Take* take, int ccidx);

// Delete a MIDI event.
REAPERAPI_DECLFUNC(bool,MIDI_DeleteEvt)(MediaItem_Take* take, int evtidx);

// Delete a MIDI note.
REAPERAPI_DECLFUNC(bool,MIDI_DeleteNote)(MediaItem_Take* take, int noteidx);

// Delete a MIDI text or sysex event.
REAPERAPI_DECLFUNC(bool,MIDI_DeleteTextSysexEvt)(MediaItem_Take* take, int textsyxevtidx);

// Returns the index of the next selected MIDI CC event after ccidx (-1 if there are no more selected events).
REAPERAPI_DECLFUNC(int,MIDI_EnumSelCC)(MediaItem_Take* take, int ccidx);

// Returns the index of the next selected MIDI event after evtidx (-1 if there are no more selected events).
REAPERAPI_DECLFUNC(int,MIDI_EnumSelEvts)(MediaItem_Take* take, int evtidx);

// Returns the index of the next selected MIDI note after noteidx (-1 if there are no more selected events).
REAPERAPI_DECLFUNC(int,MIDI_EnumSelNotes)(MediaItem_Take* take, int noteidx);

// Returns the index of the next selected MIDI text/sysex event after textsyxidx (-1 if there are no more selected events).
REAPERAPI_DECLFUNC(int,MIDI_EnumSelTextSysexEvts)(MediaItem_Take* take, int textsyxidx);

// Create a MIDI_eventlist object. The returned object must be deleted with MIDI_eventlist_destroy().
REAPERAPI_DECLFUNC(MIDI_eventlist*,MIDI_eventlist_Create)();

// Destroy a MIDI_eventlist object that was created using MIDI_eventlist_Create().
REAPERAPI_DECLFUNC(void,MIDI_eventlist_Destroy)(MIDI_eventlist* evtlist);

// Get MIDI CC event properties.
REAPERAPI_DECLFUNC(bool,MIDI_GetCC)(MediaItem_Take* take, int ccidx, bool* selectedOut, bool* mutedOut, double* ppqposOut, int* chanmsgOut, int* chanOut, int* msg2Out, int* msg3Out);

// Get MIDI event properties.
REAPERAPI_DECLFUNC(bool,MIDI_GetEvt)(MediaItem_Take* take, int evtidx, bool* selectedOut, bool* mutedOut, double* ppqposOut, char* msg, int* msg_sz);

// Get MIDI note properties.
REAPERAPI_DECLFUNC(bool,MIDI_GetNote)(MediaItem_Take* take, int noteidx, bool* selectedOut, bool* mutedOut, double* startppqposOut, double* endppqposOut, int* chanOut, int* pitchOut, int* velOut);

// Returns the MIDI tick (ppq) position corresponding to the end of the measure.
REAPERAPI_DECLFUNC(double,MIDI_GetPPQPos_EndOfMeasure)(MediaItem_Take* take, double ppqpos);

// Returns the MIDI tick (ppq) position corresponding to the start of the measure.
REAPERAPI_DECLFUNC(double,MIDI_GetPPQPos_StartOfMeasure)(MediaItem_Take* take, double ppqpos);

// Returns the MIDI tick (ppq) position corresponding to a specific project time in seconds.
REAPERAPI_DECLFUNC(double,MIDI_GetPPQPosFromProjTime)(MediaItem_Take* take, double projtime);

// Returns the project time in seconds corresponding to a specific MIDI tick (ppq) position.
REAPERAPI_DECLFUNC(double,MIDI_GetProjTimeFromPPQPos)(MediaItem_Take* take, double ppqpos);

// Get MIDI meta-event properties. Allowable types are -1:sysex (msg should not include bounding F0..F7), 1-7:MIDI text event types.
REAPERAPI_DECLFUNC(bool,MIDI_GetTextSysexEvt)(MediaItem_Take* take, int textsyxevtidx, bool* selectedOutOptional, bool* mutedOutOptional, double* ppqposOutOptional, int* typeOutOptional, char* msgOptional, int* msgOptional_sz);

// Insert a new MIDI CC event.
REAPERAPI_DECLFUNC(bool,MIDI_InsertCC)(MediaItem_Take* take, bool selected, bool muted, double ppqpos, int chanmsg, int chan, int msg2, int msg3);

// Insert a new MIDI event.
REAPERAPI_DECLFUNC(bool,MIDI_InsertEvt)(MediaItem_Take* take, bool selected, bool muted, double ppqpos, const char* msg, int msg_sz);

// Insert a new MIDI note.
REAPERAPI_DECLFUNC(bool,MIDI_InsertNote)(MediaItem_Take* take, bool selected, bool muted, double startppqpos, double endppqpos, int chan, int pitch, int vel);

// Insert a new MIDI text or sysex event. Allowable types are -1:sysex (msg should include bounding F0..F7), 1-7:MIDI text event types.
REAPERAPI_DECLFUNC(bool,MIDI_InsertTextSysexEvt)(MediaItem_Take* take, bool selected, bool muted, double ppqpos, int type, const char* msg, int msg_sz);

// Reset all MIDI devices
REAPERAPI_DECLFUNC(void,midi_reinit)();

// Set MIDI CC event properties. Properties passed as NULL will not be set.
REAPERAPI_DECLFUNC(bool,MIDI_SetCC)(MediaItem_Take* take, int ccidx, const bool* selectedInOptional, const bool* mutedInOptional, const double* ppqposInOptional, const int* chanmsgInOptional, const int* chanInOptional, const int* msg2InOptional, const int* msg3InOptional);

// Set MIDI event properties. Properties passed as NULL will not be set.
REAPERAPI_DECLFUNC(bool,MIDI_SetEvt)(MediaItem_Take* take, int evtidx, const bool* selectedInOptional, const bool* mutedInOptional, const double* ppqposInOptional, const char* msgOptional, int msgOptional_sz);

// Set MIDI note properties. Properties passed as NULL will not be set.
REAPERAPI_DECLFUNC(bool,MIDI_SetNote)(MediaItem_Take* take, int noteidx, const bool* selectedInOptional, const bool* mutedInOptional, const double* startppqposInOptional, const double* endppqposInOptional, const int* chanInOptional, const int* pitchInOptional, const int* velInOptional);

// Set MIDI text or sysex event properties. Properties passed as NULL will not be set. Allowable types are -1:sysex (msg should not include bounding F0..F7), 1-7:MIDI text event types.
REAPERAPI_DECLFUNC(bool,MIDI_SetTextSysexEvt)(MediaItem_Take* take, int textsyxevtidx, const bool* selectedInOptional, const bool* mutedInOptional, const double* ppqposInOptional, const int* typeInOptional, const char* msgOptional, int msgOptional_sz);

// get a pointer to the focused MIDI editor window
// see MIDIEditor_GetMode, MIDIEditor_OnCommand
REAPERAPI_DECLFUNC(void*,MIDIEditor_GetActive)();

// get the mode of a MIDI editor (0=piano roll, 1=event list, -1=invalid editor)
// see MIDIEditor_GetActive, MIDIEditor_OnCommand
REAPERAPI_DECLFUNC(int,MIDIEditor_GetMode)(void* midieditor);

// Get settings from a MIDI editor. setting_desc can be:
// snap_enabled: returns 0 or 1
// active_note_row: returns 0-127
// last_clicked_cc_lane: returns 0-127=CC, 0x100|(0-31)=14-bit CC, 0x200=velocity, 0x201=pitch, 0x202=program, 0x203=channel pressure, 0x204=bank/program select, 0x205=text, 0x206=sysex
// default_note_vel: returns 0-127
// default_note_chan: returns 0-15
// default_note_len: returns default length in MIDI ticks
// scale_enabled: returns 0-1
// scale_root: returns 0-12 (0=C)
// if setting_desc is unsupported, the function returns -1.
// See MIDIEditor_GetActive, MIDIEditor_GetSetting_str
REAPERAPI_DECLFUNC(int,MIDIEditor_GetSetting_int)(void* midieditor, const char* setting_desc);

// Get settings from a MIDI editor. setting_desc can be:
// last_clicked_cc_lane: returns text description ("velocity", "pitch", etc)
// scale: returns the scale record, for example "102034050607" for a major scale
// if setting_desc is unsupported, the function returns false.
// See MIDIEditor_GetActive, MIDIEditor_GetSetting_int
REAPERAPI_DECLFUNC(bool,MIDIEditor_GetSetting_str)(void* midieditor, const char* setting_desc, char* buf, int buf_sz);

// get the take that is currently being edited in this MIDI editor
REAPERAPI_DECLFUNC(MediaItem_Take*,MIDIEditor_GetTake)(void* midieditor);

// Send an action command to the last focused MIDI editor. Returns false if there is no MIDI editor open, or if the view mode (piano roll or event list) does not match the input.
// see MIDIEditor_OnCommand
REAPERAPI_DECLFUNC(bool,MIDIEditor_LastFocused_OnCommand)(int command_id, bool islistviewcommand);

// Send an action command to a MIDI editor. Returns false if the supplied MIDI editor pointer is not valid (not an open MIDI editor).
// see MIDIEditor_GetActive, MIDIEditor_LastFocused_OnCommand
REAPERAPI_DECLFUNC(bool,MIDIEditor_OnCommand)(void* midieditor, int command_id);

REAPERAPI_DECLFUNC(void,mkpanstr)(char* strNeed64, double pan);

REAPERAPI_DECLFUNC(void,mkvolpanstr)(char* strNeed64, double vol, double pan);

REAPERAPI_DECLFUNC(void,mkvolstr)(char* strNeed64, double vol);

REAPERAPI_DECLFUNC(void,MoveEditCursor)(double adjamt, bool dosel);

// returns TRUE if move succeeded
REAPERAPI_DECLFUNC(bool,MoveMediaItemToTrack)(MediaItem* item, MediaTrack* desttr);

REAPERAPI_DECLFUNC(void,MuteAllTracks)(bool mute);

REAPERAPI_DECLFUNC(void,my_getViewport)(RECT* r, const RECT* sr, bool wantWorkArea);

// get the command ID number for named command that was registered by an extension (such as "_SWS_ABOUT", etc)
REAPERAPI_DECLFUNC(int,NamedCommandLookup)(const char* command_name);

// direct way to simulate pause button hit
REAPERAPI_DECLFUNC(void,OnPauseButton)();

// direct way to simulate pause button hit
REAPERAPI_DECLFUNC(void,OnPauseButtonEx)(ReaProject* proj);

// direct way to simulate play button hit
REAPERAPI_DECLFUNC(void,OnPlayButton)();

// direct way to simulate play button hit
REAPERAPI_DECLFUNC(void,OnPlayButtonEx)(ReaProject* proj);

// direct way to simulate stop button hit
REAPERAPI_DECLFUNC(void,OnStopButton)();

// direct way to simulate stop button hit
REAPERAPI_DECLFUNC(void,OnStopButtonEx)(ReaProject* proj);

// Send an OSC message directly to REAPER. The value argument may be NULL. The message will be matched against the default OSC patterns. Only supported if control surface support was enabled when installing REAPER.
REAPERAPI_DECLFUNC(void,OscLocalMessageToHost)(const char* message, const double* valueInOptional);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECLFUNC(double,parse_timestr)(const char* buf);

// time formatting mode overrides: -1=proj default.
// 0=time
// 1=measures.beats + time
// 2=measures.beats
// 3=seconds
// 4=samples
// 5=h:m:s:f
REAPERAPI_DECLFUNC(double,parse_timestr_len)(const char* buf, double offset, int modeoverride);

// parses time string,modeoverride see above
REAPERAPI_DECLFUNC(double,parse_timestr_pos)(const char* buf, int modeoverride);

REAPERAPI_DECLFUNC(double,parsepanstr)(const char* str);

REAPERAPI_DECLFUNC(PCM_sink*,PCM_Sink_Create)(const char* filename, const char* cfg, int cfg_sz, int nch, int srate, bool buildpeaks);

REAPERAPI_DECLFUNC(PCM_sink*,PCM_Sink_CreateEx)(ReaProject* proj, const char* filename, const char* cfg, int cfg_sz, int nch, int srate, bool buildpeaks);

REAPERAPI_DECLFUNC(PCM_sink*,PCM_Sink_CreateMIDIFile)(const char* filename, const char* cfg, int cfg_sz, double bpm, int div);

REAPERAPI_DECLFUNC(PCM_sink*,PCM_Sink_CreateMIDIFileEx)(ReaProject* proj, const char* filename, const char* cfg, int cfg_sz, double bpm, int div);

REAPERAPI_DECLFUNC(unsigned int,PCM_Sink_Enum)(int idx, const char** descstrOut);

REAPERAPI_DECLFUNC(const char*,PCM_Sink_GetExtension)(const char* data, int data_sz);

REAPERAPI_DECLFUNC(HWND,PCM_Sink_ShowConfig)(const char* cfg, int cfg_sz, HWND hwndParent);

REAPERAPI_DECLFUNC(PCM_source*,PCM_Source_CreateFromFile)(const char* filename);

REAPERAPI_DECLFUNC(PCM_source*,PCM_Source_CreateFromFileEx)(const char* filename, bool forcenoMidiImp);

// Creates a PCM_source from a ISimpleMediaDecoder
// (if fn is non-null, it will open the file in dec)
REAPERAPI_DECLFUNC(PCM_source*,PCM_Source_CreateFromSimple)(ISimpleMediaDecoder* dec, const char* fn);

REAPERAPI_DECLFUNC(PCM_source*,PCM_Source_CreateFromType)(const char* sourcetype);

// If a section/reverse block, retrieves offset/len/reverse. return true if success
REAPERAPI_DECLFUNC(bool,PCM_Source_GetSectionInfo)(PCM_source* src, double* offsOut, double* lenOut, bool* revOut);

REAPERAPI_DECLFUNC(REAPER_PeakBuild_Interface*,PeakBuild_Create)(PCM_source* src, const char* fn, int srate, int nch);

REAPERAPI_DECLFUNC(REAPER_PeakGet_Interface*,PeakGet_Create)(const char* fn, int srate, int nch);

// return nonzero on success
REAPERAPI_DECLFUNC(int,PlayPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECLFUNC(int,PlayPreviewEx)(preview_register_t* preview, int bufflags, double MSI);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECLFUNC(int,PlayTrackPreview)(preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECLFUNC(int,PlayTrackPreview2)(ReaProject* proj, preview_register_t* preview);

// return nonzero on success,in these,m_out_chan is a track index (0-n)
REAPERAPI_DECLFUNC(int,PlayTrackPreview2Ex)(ReaProject* proj, preview_register_t* preview, int flags, double msi);

REAPERAPI_DECLFUNC(void*,plugin_getapi)(const char* name);

REAPERAPI_DECLFUNC(const char*,plugin_getFilterList)();

REAPERAPI_DECLFUNC(const char*,plugin_getImportableProjectFilterList)();

// like rec->Register
// 
// if you have a function called myfunction(..) that you want to expose to other extensions or plug-ins,
// use register("API_myfunction",funcaddress), and "-API_myfunction" to remove.
// Other extensions then use GetFunc("myfunction") to get the function pointer.
// REAPER will also export the function address to ReaScript, so your extension could supply
// a Python module that provides a wrapper called RPR_myfunction(..).
// register("APIdef_myfunction",defstring) will include your function declaration and help
// in the auto-generated REAPER API header and ReaScript documentation.
// defstring is four null-separated fields: return type, argument types, argument names, and help.
// Example: double myfunction(char* str, int flag) would have
// defstring="double\0char*,int\0str,flag\0help text for myfunction"
// 
// another thing you can register is "hookcommand", which you pass a callback:
//  NON_API: bool runCommand(int command, int flag);
//           register("hookcommand",runCommand);
// which returns TRUE to eat (process) the command.
// flag is usually 0 but can sometimes have useful info depending on the message.
// note: it's OK to call Main_OnCommand() within your runCommand, however you MUST check for recursion if doing so!
// in fact, any use of this hook should benefit from a simple reentrancy test...
// 
// to get notified when an action of the main section is performed,
// you can register "hookpostcommand", which you pass a callback:
//  NON_API: void postCommand(int command, int flag);
//           register("hookpostcommand",postCommand);
// 
// you can also register "hookcommand2", which you pass a callback:
//  NON_API: bool onAction(KbdSectionInfo *sec, int command, int val, int valhw, int relmode, HWND hwnd);
//           register("hookcommand2",onAction);
// which returns TRUE to eat (process) the command.
// val/valhw are used for actions learned with MIDI/OSC.
// val = [0..127] and valhw = -1 for MIDI CC, 
// valhw >=0 for MIDI pitch or OSC with value = (valhw|val<<7)/16383.0, 
// relmode absolute(0) or 1/2/3 for relative adjust modes
// 
// you can also register command IDs for actions,
// register with "command_id", parameter is a unique string with only A-Z, 0-9,
// returns command ID (or 0 if not supported/out of actions)
// 
// register("command_id_lookup", unique_string) will look up the integer ID of the named action
// without registering the string if it doesn't already exist.
REAPERAPI_DECLFUNC(int,plugin_register)(const char* name, void* infostruct);

REAPERAPI_DECLFUNC(void,PluginWantsAlwaysRunFx)(int amt);

// adds prevent_count to the UI refresh prevention state; always add then remove the same amount, or major disfunction will occur
REAPERAPI_DECLFUNC(void,PreventUIRefresh)(int prevent_count);

REAPERAPI_DECLFUNC(void*,projectconfig_var_addr)(ReaProject* proj, int idx);

// returns offset to pass to projectconfig_var_addr() to get project-config var of name. szout gets size of object.
REAPERAPI_DECLFUNC(int,projectconfig_var_getoffs)(const char* name, int* szOut);

// version must be REAPER_PITCHSHIFT_API_VER
REAPERAPI_DECLFUNC(IReaperPitchShift*,ReaperGetPitchShiftAPI)(int version);

// Causes REAPER to display the error message after the current ReaScript finishes.
REAPERAPI_DECLFUNC(void,ReaScriptError)(const char* errmsg);

REAPERAPI_DECLFUNC(int,RecursiveCreateDirectory)(const char* path, size_t ignored);

// refresh the toolbar button state of a toggle action
REAPERAPI_DECLFUNC(void,RefreshToolbar)(int command_id);

REAPERAPI_DECLFUNC(void,relative_fn)(const char* in, char* out, int out_sz);

REAPERAPI_DECLFUNC(bool,RenderFileSection)(const char* source_filename, const char* target_filename, double start_percent, double end_percent, double playrate);

REAPERAPI_DECLFUNC(const char*,Resample_EnumModes)(int mode);

REAPERAPI_DECLFUNC(REAPER_Resample_Interface*,Resampler_Create)();

REAPERAPI_DECLFUNC(void,resolve_fn)(const char* in, char* out, int out_sz);

REAPERAPI_DECLFUNC(void,resolve_fn2)(const char* in, char* out, int out_sz, const char* checkSubDirOptional);

// get the named command for command ID number. the returned string won't start with '_' (e.g. it will return "SWS_ABOUT" for the SWS about box action), it will be NULL if cmd is a native action.
REAPERAPI_DECLFUNC(const char*,ReverseNamedCommandLookup)(int cmd);

REAPERAPI_DECLFUNC(void,screenset_register)(char* id, void* callbackFunc, void* param);

REAPERAPI_DECLFUNC(void,screenset_registerNew)(char* id, screensetNewCallbackFunc callbackFunc, void* param);

REAPERAPI_DECLFUNC(void,screenset_unregister)(char* id);

REAPERAPI_DECLFUNC(void,screenset_unregisterByParam)(void* param);

REAPERAPI_DECLFUNC(KbdSectionInfo*,SectionFromUniqueID)(int uniqueID);

REAPERAPI_DECLFUNC(void,SelectAllMediaItems)(ReaProject* proj, bool selected);

REAPERAPI_DECLFUNC(void,SelectProjectInstance)(ReaProject* proj);

// Send an OSC message to REAPER. See CreateLocalOscHandler, DestroyLocalOscHandler.
REAPERAPI_DECLFUNC(void,SendLocalOscMessage)(void* local_osc_handler, const char* msg, int msglen);

// set this take active in this media item
REAPERAPI_DECLFUNC(void,SetActiveTake)(MediaItem_Take* take);

// sets all or selected tracks to mode.
REAPERAPI_DECLFUNC(void,SetAutomationMode)(int mode, bool onlySel);

// set current BPM in project, set wantUndo=true to add undo point
REAPERAPI_DECLFUNC(void,SetCurrentBPM)(ReaProject* __proj, double bpm, bool wantUndo);

// You must use this to change the focus programmatically. mode=0 to focus track panels, 1 to focus the arrange window, 2 to focus the arrange window and select env (or env==NULL to clear the current track/take envelope selection)
REAPERAPI_DECLFUNC(void,SetCursorContext)(int mode, void* env);

REAPERAPI_DECLFUNC(void,SetEditCurPos)(double time, bool moveview, bool seekplay);

REAPERAPI_DECLFUNC(void,SetEditCurPos2)(ReaProject* proj, double time, bool moveview, bool seekplay);

// Set the extended state value for a specific section and key. persist=true means the value should be stored and reloaded the next time REAPER is opened. See GetExtState, DeleteExtState, HasExtState.
REAPERAPI_DECLFUNC(void,SetExtState)(const char* section, const char* key, const char* value, bool persist);

// mode: see GetGlobalAutomationOverride
REAPERAPI_DECLFUNC(void,SetGlobalAutomationOverride)(int mode);

// set &1 to show the master track in the TCP, &2 to show in the mixer. Returns the previous visibility state. See GetMasterTrackVisibility.
REAPERAPI_DECLFUNC(int,SetMasterTrackVisibility)(int flag);

// Set media item numerical-value attributes.
// B_MUTE : bool * to muted state
// B_LOOPSRC : bool * to loop source
// B_ALLTAKESPLAY : bool * to all takes play
// B_UISEL : bool * to ui selected
// C_BEATATTACHMODE : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsosonly
// C_LOCK : char * to one char of lock flags (&1 is locked, currently)
// D_VOL : double * of item volume (volume bar)
// D_POSITION : double * of item position (seconds)
// D_LENGTH : double * of item length (seconds)
// D_SNAPOFFSET : double * of item snap offset (seconds)
// D_FADEINLEN : double * of item fade in length (manual, seconds)
// D_FADEOUTLEN : double * of item fade out length (manual, seconds)
// D_FADEINLEN_AUTO : double * of item autofade in length (seconds, -1 for no autofade set)
// D_FADEOUTLEN_AUTO : double * of item autofade out length (seconds, -1 for no autofade set)
// C_FADEINSHAPE : int * to fadein shape, 0=linear, ...
// C_FADEOUTSHAPE : int * to fadeout shape
// I_GROUPID : int * to group ID (0 = no group)
// I_LASTY : int * to last y position in track (readonly)
// I_LASTH : int * to last height in track (readonly)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_CURTAKE : int * to active take
// IP_ITEMNUMBER : int, item number within the track (read-only, returns the item number directly)
// F_FREEMODE_Y : float * to free mode y position (0..1)
// F_FREEMODE_H : float * to free mode height (0..1)
REAPERAPI_DECLFUNC(bool,SetMediaItemInfo_Value)(MediaItem* item, const char* parmname, double newvalue);

// Redraws the screen only if refreshUI == true.
// See UpdateArrange().
REAPERAPI_DECLFUNC(bool,SetMediaItemLength)(MediaItem* item, double length, bool refreshUI);

// Redraws the screen only if refreshUI == true.
// See UpdateArrange().
REAPERAPI_DECLFUNC(bool,SetMediaItemPosition)(MediaItem* item, double position, bool refreshUI);

REAPERAPI_DECLFUNC(void,SetMediaItemSelected)(MediaItem* item, bool selected);

// Set media item take numerical-value attributes.
// D_STARTOFFS : double *, start offset in take of item
// D_VOL : double *, take volume
// D_PAN : double *, take pan
// D_PANLAW : double *, take pan law (-1.0=default, 0.5=-6dB, 1.0=+0dB, etc)
// D_PLAYRATE : double *, take playrate (1.0=normal, 2.0=doublespeed, etc)
// D_PITCH : double *, take pitch adjust (in semitones, 0.0=normal, +12 = one octave up, etc)
// B_PPITCH, bool *, preserve pitch when changing rate
// I_CHANMODE, int *, channel mode (0=normal, 1=revstereo, 2=downmix, 3=l, 4=r)
// I_PITCHMODE, int *, pitch shifter mode, -1=proj default, otherwise high word=shifter low word = parameter
// I_CUSTOMCOLOR : int *, custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// IP_TAKENUMBER : int, take number within the item (read-only, returns the take number directly)
REAPERAPI_DECLFUNC(bool,SetMediaItemTakeInfo_Value)(MediaItem_Take* take, const char* parmname, double newvalue);

// Set track numerical-value attributes.
// B_MUTE : bool * : mute flag
// B_PHASE : bool * : invert track phase
// IP_TRACKNUMBER : int : track number (returns zero if not found, -1 for master track) (read-only, returns the int directly)
// I_SOLO : int * : 0=not soloed, 1=solo, 2=soloed in place
// I_FXEN : int * : 0=fx bypassed, nonzero = fx active
// I_RECARM : int * : 0=not record armed, 1=record armed
// I_RECINPUT : int * : record input. <0 = no input, 0..n = mono hardware input, 512+n = rearoute input, 1024 set for stereo input pair. 4096 set for MIDI input, if set, then low 5 bits represent channel (0=all, 1-16=only chan), then next 5 bits represent physical input (31=all, 30=VKB)
// I_RECMODE : int * : record mode (0=input, 1=stereo out, 2=none, 3=stereo out w/latcomp, 4=midi output, 5=mono out, 6=mono out w/ lat comp, 7=midi overdub, 8=midi replace
// I_RECMON : int * : record monitor (0=off, 1=normal, 2=not when playing (tapestyle))
// I_RECMONITEMS : int * : monitor items while recording (0=off, 1=on)
// I_AUTOMODE : int * : track automation mode (0=trim/off, 1=read, 2=touch, 3=write, 4=latch
// I_NCHAN : int * : number of track channels, must be 2-64, even
// I_SELECTED : int * : track selected? 0 or 1
// I_WNDH : int * : current TCP window height (Read-only)
// I_FOLDERDEPTH : int * : folder depth change (0=normal, 1=track is a folder parent, -1=track is the last in the innermost folder, -2=track is the last in the innermost and next-innermost folders, etc
// I_FOLDERCOMPACT : int * : folder compacting (only valid on folders), 0=normal, 1=small, 2=tiny children
// I_MIDIHWOUT : int * : track midi hardware output index (<0 for disabled, low 5 bits are which channels (0=all, 1-16), next 5 bits are output device index (0-31))
// I_PERFFLAGS : int * : track perf flags (&1=no media buffering, &2=no anticipative FX)
// I_CUSTOMCOLOR : int * : custom color, windows standard color order (i.e. RGB(r,g,b)|0x100000). if you do not |0x100000, then it will not be used (though will store the color anyway)
// I_HEIGHTOVERRIDE : int * : custom height override for TCP window. 0 for none, otherwise size in pixels
// D_VOL : double * : trim volume of track (0 (-inf)..1 (+0dB) .. 2 (+6dB) etc ..)
// D_PAN : double * : trim pan of track (-1..1)
// D_WIDTH : double * : width of track (-1..1)
// D_DUALPANL : double * : dualpan position 1 (-1..1), only if I_PANMODE==6
// D_DUALPANR : double * : dualpan position 2 (-1..1), only if I_PANMODE==6
// I_PANMODE : int * : pan mode (0 = classic 3.x, 3=new balance, 5=stereo pan, 6 = dual pan)
// D_PANLAW : double * : pan law of track. <0 for project default, 1.0 for +0dB, etc
// P_ENV : read only, returns TrackEnvelope *, setNewValue=<VOLENV, <PANENV, etc
// B_SHOWINMIXER : bool * : show track panel in mixer -- do not use on master
// B_SHOWINTCP : bool * : show track panel in tcp -- do not use on master
// B_MAINSEND : bool * : track sends audio to parent
// B_FREEMODE : bool * : track free-mode enabled (requires UpdateTimeline() after changing etc)
// C_BEATATTACHMODE : char * : char * to one char of beat attached mode, -1=def, 0=time, 1=allbeats, 2=beatsposonly
// F_MCP_FXSEND_SCALE : float * : scale of fx+send area in MCP (0.0=smallest allowed, 1=max allowed)
// F_MCP_SENDRGN_SCALE : float * : scale of send area as proportion of the fx+send total area (0=min allow, 1=max)
REAPERAPI_DECLFUNC(bool,SetMediaTrackInfo_Value)(MediaTrack* tr, const char* parmname, double newvalue);

// Scroll the mixer so that leftmosttrack is the leftmost visible track. Returns the leftmost track after scrolling, which may be different from the passed-in track if there are not enough tracks to its right.
REAPERAPI_DECLFUNC(MediaTrack*,SetMixerScroll)(MediaTrack* leftmosttrack);

// Set the mouse modifier assignment for a specific modifier key assignment, in a specific context.
// Context is a string like "MM_CTX_ITEM". Find these strings by modifying an assignment in 
// Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.
// Modifier flag is a number from 0 to 15: add 1 for shift, 2 for control, 4 for alt, 8 for win.
// (OSX: add 1 for shift, 2 for command, 4 for opt, 8 for control.)
// For left-click and double-click contexts, the action can be any built-in command ID number
// or any custom action ID string. Find built-in command IDs in the REAPER actions window
// (enable "show action IDs" in the context menu), and find custom action ID strings in reaper-kb.ini.
// For built-in mouse modifier behaviors, find action IDs (which will be low numbers)
// by modifying an assignment in Preferences/Editing/Mouse Modifiers, then looking in reaper-mouse.ini.
// Assigning an action of -1 will reset that mouse modifier behavior to factory default.
// See GetMouseModifier.
// 
REAPERAPI_DECLFUNC(void,SetMouseModifier)(const char* context, int modifier_flag, const char* action);

// Set exactly one track selected, deselect all others
REAPERAPI_DECLFUNC(void,SetOnlyTrackSelected)(MediaTrack* track);

REAPERAPI_DECLFUNC(bool,SetProjectMarker)(int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

REAPERAPI_DECLFUNC(bool,SetProjectMarker2)(ReaProject* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name);

REAPERAPI_DECLFUNC(bool,SetProjectMarker3)(ReaProject* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name, int color);

// color should be 0 to not change, or RGB(x,y,z)|0x1000000 to set custom, flags&1 to clear name
REAPERAPI_DECLFUNC(bool,SetProjectMarker4)(ReaProject* proj, int markrgnindexnumber, bool isrgn, double pos, double rgnend, const char* name, int color, int flags);

// See SetProjectMarkerByIndex2.
REAPERAPI_DECLFUNC(bool,SetProjectMarkerByIndex)(ReaProject* proj, int markrgnidx, bool isrgn, double pos, double rgnend, int IDnumber, const char* name, int color);

// Differs from SetProjectMarker4 in that markrgnidx is 0 for the first marker/region, 1 for the next, etc (see EnumProjectMarkers3), rather than representing the displayed marker/region ID number (see SetProjectMarker3). Function will fail if attempting to set a duplicate ID number for a region (duplicate ID numbers for markers are OK). , flags&1 to clear name.
REAPERAPI_DECLFUNC(bool,SetProjectMarkerByIndex2)(ReaProject* proj, int markrgnidx, bool isrgn, double pos, double rgnend, int IDnumber, const char* name, int color, int flags);

// Add (addorremove > 0) or remove (addorremove < 0) a track from this region when using the region render matrix.
REAPERAPI_DECLFUNC(void,SetRegionRenderMatrix)(ReaProject* proj, int regionindex, MediaTrack* track, int addorremove);

// Used by pcmsink objects to set an error to display while creating the pcmsink object.
REAPERAPI_DECLFUNC(void,SetRenderLastError)(const char* errorstr);

// Adds or updates a stretch marker. If idx<0, stretch marker will be added. If idx>=0, stretch marker will be updated. When adding, if srcposInOptional is omitted, source position will be auto-calculated. When updating a stretch marker, if srcposInOptional is omitted, srcpos will not be modified. Position/srcposition values will be constrained to nearby stretch markers. Returns index of stretch marker, or -1 if did not insert (or marker already existed at time).
REAPERAPI_DECLFUNC(int,SetTakeStretchMarker)(MediaItem_Take* take, int idx, double pos, const double* srcposInOptional);

// Set parameters of a tempo/time signature marker. Provide either timepos (with measurepos=-1, beatpos=-1), or measurepos and beatpos (with timepos=-1). If timesig_num and timesig_denom are zero, the previous time signature will be used. ptidx=-1 will insert a new tempo/time signature marker. See CountTempoTimeSigMarkers, GetTempoTimeSigMarker, AddTempoTimeSigMarker.
REAPERAPI_DECLFUNC(bool,SetTempoTimeSigMarker)(ReaProject* proj, int ptidx, double timepos, int measurepos, double beatpos, double bpm, int timesig_num, int timesig_denom, bool lineartempo);

REAPERAPI_DECLFUNC(void,SetTrackAutomationMode)(MediaTrack* tr, int mode);

// Set the track color, as 0x00RRGGBB.
REAPERAPI_DECLFUNC(void,SetTrackColor)(MediaTrack* track, int color);

REAPERAPI_DECLFUNC(bool,SetTrackMIDINoteName)(int track, int note, int chan, const char* name);

REAPERAPI_DECLFUNC(bool,SetTrackMIDINoteNameEx)(ReaProject* proj, MediaTrack* track, int note, int chan, const char* name);

REAPERAPI_DECLFUNC(void,SetTrackSelected)(MediaTrack* track, bool selected);

// send_idx<0 for receives, isend=1 for end of edit, -1 for an instant edit (such as reset), 0 for normal tweak.
REAPERAPI_DECLFUNC(bool,SetTrackSendUIPan)(MediaTrack* track, int send_idx, double pan, int isend);

// send_idx<0 for receives, isend=1 for end of edit, -1 for an instant edit (such as reset), 0 for normal tweak.
REAPERAPI_DECLFUNC(bool,SetTrackSendUIVol)(MediaTrack* track, int send_idx, double vol, int isend);

REAPERAPI_DECLFUNC(void,ShowActionList)(KbdSectionInfo* caller, HWND callerWnd);

// Show a message to the user (also useful for debugging). Send "\n" for newline, "" to clear the console window.
REAPERAPI_DECLFUNC(void,ShowConsoleMsg)(const char* msg);

// type 0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL : ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO
REAPERAPI_DECLFUNC(int,ShowMessageBox)(const char* msg, const char* title, int type);

REAPERAPI_DECLFUNC(double,SLIDER2DB)(double y);

REAPERAPI_DECLFUNC(double,SnapToGrid)(ReaProject* project, double time_pos);

// solo=2 for SIP
REAPERAPI_DECLFUNC(void,SoloAllTracks)(int solo);

// gets the splash window, in case you want to display a message over it. Returns NULL when the sphah window is not displayed.
REAPERAPI_DECLFUNC(HWND,Splash_GetWnd)();

// the original item becomes the left-hand split, the function returns the right-hand split (or NULL if the split failed)
REAPERAPI_DECLFUNC(MediaItem*,SplitMediaItem)(MediaItem* item, double position);

// return nonzero on success
REAPERAPI_DECLFUNC(int,StopPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECLFUNC(int,StopTrackPreview)(preview_register_t* preview);

// return nonzero on success
REAPERAPI_DECLFUNC(int,StopTrackPreview2)(void* proj, preview_register_t* preview);

REAPERAPI_DECLFUNC(void,stringToGuid)(const char* str, GUID* g);

// Stuffs a 3 byte MIDI message into either the Virtual MIDI Keyboard queue, or the MIDI-as-control input queue. mode=0 for VKB, 1 for control (actions map etc), 2 for VKB-on-current-channel.
REAPERAPI_DECLFUNC(void,StuffMIDIMessage)(int mode, int msg1, int msg2, int msg3);

// convert a beat position (or optionally a beats+measures if measures is non-NULL) to time.
REAPERAPI_DECLFUNC(double,TimeMap2_beatsToTime)(ReaProject* proj, double tpos, int* measuresOutOptional);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECLFUNC(double,TimeMap2_GetDividedBpmAtTime)(ReaProject* proj, double time);

// when does the next time map (tempo or time sig) change occur
REAPERAPI_DECLFUNC(double,TimeMap2_GetNextChangeTime)(ReaProject* proj, double time);

// converts project QN position to time.
REAPERAPI_DECLFUNC(double,TimeMap2_QNToTime)(ReaProject* proj, double qn);

// convert a time into beats.
// if measures is non-NULL, measures will be set to the measure count, return value will be beats since measure.
// if cml is non-NULL, will be set to current measure length in beats (i.e. time signature numerator)
// if fullbeats is non-NULL, and measures is non-NULL, fullbeats will get the full beat count (same value returned if measures is NULL).
// if cdenom is non-NULL, will be set to the current time signature denominator.
REAPERAPI_DECLFUNC(double,TimeMap2_timeToBeats)(ReaProject* proj, double tpos, int* measuresOutOptional, int* cmlOutOptional, double* fullbeatsOutOptional, int* cdenomOutOptional);

// converts project time position to QN position.
REAPERAPI_DECLFUNC(double,TimeMap2_timeToQN)(ReaProject* proj, double tpos);

// Gets project framerate, and optionally whether it is drop-frame timecode
REAPERAPI_DECLFUNC(double,TimeMap_curFrameRate)(ReaProject* proj, bool* dropFrameOutOptional);

// get the effective BPM at the time (seconds) position (i.e. 2x in /8 signatures)
REAPERAPI_DECLFUNC(double,TimeMap_GetDividedBpmAtTime)(double time);

// get the effective time signature and tempo
REAPERAPI_DECLFUNC(void,TimeMap_GetTimeSigAtTime)(ReaProject* proj, double time, int* timesig_numOut, int* timesig_denomOut, double* tempoOut);

// converts project QN position to time.
REAPERAPI_DECLFUNC(double,TimeMap_QNToTime)(double qn);

// Converts project quarter note count (QN) to time. QN is counted from the start of the project, regardless of any partial measures. See TimeMap2_QNToTime
REAPERAPI_DECLFUNC(double,TimeMap_QNToTime_abs)(ReaProject* proj, double qn);

// converts project QN position to time.
REAPERAPI_DECLFUNC(double,TimeMap_timeToQN)(double qn);

// Converts project time position to quarter note count (QN). QN is counted from the start of the project, regardless of any partial measures. See TimeMap2_timeToQN
REAPERAPI_DECLFUNC(double,TimeMap_timeToQN_abs)(ReaProject* proj, double tpos);

// send_idx<0 for receives
REAPERAPI_DECLFUNC(bool,ToggleTrackSendUIMute)(MediaTrack* track, int send_idx);

REAPERAPI_DECLFUNC(double,Track_GetPeakHoldDB)(MediaTrack* track, int channel, bool clear);

REAPERAPI_DECLFUNC(double,Track_GetPeakInfo)(MediaTrack* track, int channel);

// displays tooltip at location, or removes if empty string
REAPERAPI_DECLFUNC(void,TrackCtl_SetToolTip)(const char* fmt, int xpos, int ypos, bool topmost);

REAPERAPI_DECLFUNC(bool,TrackFX_EndParamEdit)(MediaTrack* track, int fx, int param);

// Note: only works with FX that support Cockos VST extensions.
REAPERAPI_DECLFUNC(bool,TrackFX_FormatParamValue)(MediaTrack* track, int fx, int param, double val, char* buf, int buf_sz);

// Note: only works with FX that support Cockos VST extensions.
REAPERAPI_DECLFUNC(bool,TrackFX_FormatParamValueNormalized)(MediaTrack* track, int fx, int param, double value, char* buf, int buf_sz);

// Get the index of the first track FX insert that matches fxname. If the FX is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetEQ.
REAPERAPI_DECLFUNC(int,TrackFX_GetByName)(MediaTrack* track, const char* fxname, bool instantiate);

// returns index of effect visible in chain, or -1 for chain hidden, or -2 for chain visible but no effect selected
REAPERAPI_DECLFUNC(int,TrackFX_GetChainVisible)(MediaTrack* track);

REAPERAPI_DECLFUNC(int,TrackFX_GetCount)(MediaTrack* track);

// See TrackFX_SetEnabled
REAPERAPI_DECLFUNC(bool,TrackFX_GetEnabled)(MediaTrack* track, int fx);

// Get the index of ReaEQ in the track FX chain. If ReaEQ is not in the chain and instantiate is true, it will be inserted. See TrackFX_GetInstrument, TrackFX_GetByName.
REAPERAPI_DECLFUNC(int,TrackFX_GetEQ)(MediaTrack* track, bool instantiate);

// Returns true if the EQ band is enabled.
// Returns false if the band is disabled, or if track/fxidx is not ReaEQ.
// Bandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_SetEQBandEnabled.
REAPERAPI_DECLFUNC(bool,TrackFX_GetEQBandEnabled)(MediaTrack* track, int fxidx, int bandtype, int bandidx);

// Returns false if track/fxidx is not ReaEQ.
// Bandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx (ignored for master gain): 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// Paramtype (ignored for master gain): 0=freq, 1=gain, 2=Q.
// See TrackFX_GetEQ, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.
REAPERAPI_DECLFUNC(bool,TrackFX_GetEQParam)(MediaTrack* track, int fxidx, int paramidx, int* bandtypeOut, int* bandidxOut, int* paramtypeOut, double* normvalOut);

// returns HWND of floating window for effect index, if any
REAPERAPI_DECLFUNC(HWND,TrackFX_GetFloatingWindow)(MediaTrack* track, int index);

REAPERAPI_DECLFUNC(bool,TrackFX_GetFormattedParamValue)(MediaTrack* track, int fx, int param, char* buf, int buf_sz);

REAPERAPI_DECLFUNC(GUID*,TrackFX_GetFXGUID)(MediaTrack* track, int fx);

REAPERAPI_DECLFUNC(bool,TrackFX_GetFXName)(MediaTrack* track, int fx, char* buf, int buf_sz);

// Get the index of the first track FX insert that is a virtual instrument, or -1 if none. See TrackFX_GetEQ, TrackFX_GetByName.
REAPERAPI_DECLFUNC(int,TrackFX_GetInstrument)(MediaTrack* track);

REAPERAPI_DECLFUNC(int,TrackFX_GetNumParams)(MediaTrack* track, int fx);

// Returns true if this FX UI is open in the FX chain window or a floating window. See TrackFX_SetOpen
REAPERAPI_DECLFUNC(bool,TrackFX_GetOpen)(MediaTrack* track, int fx);

REAPERAPI_DECLFUNC(double,TrackFX_GetParam)(MediaTrack* track, int fx, int param, double* minvalOut, double* maxvalOut);

REAPERAPI_DECLFUNC(bool,TrackFX_GetParameterStepSizes)(MediaTrack* track, int fx, int param, double* stepOut, double* smallstepOut, double* largestepOut, bool* istoggleOut);

REAPERAPI_DECLFUNC(double,TrackFX_GetParamEx)(MediaTrack* track, int fx, int param, double* minvalOut, double* maxvalOut, double* midvalOut);

REAPERAPI_DECLFUNC(bool,TrackFX_GetParamName)(MediaTrack* track, int fx, int param, char* buf, int buf_sz);

REAPERAPI_DECLFUNC(double,TrackFX_GetParamNormalized)(MediaTrack* track, int fx, int param);

// Get the name of the preset currently showing in the REAPER dropdown. Returns false if the current FX parameters do not exactly match the factory preset (in other words, if the user loaded the preset but moved the knobs afterward. See TrackFX_SetPreset
REAPERAPI_DECLFUNC(bool,TrackFX_GetPreset)(MediaTrack* track, int fx, char* presetname, int presetname_sz);

// Returns current preset index, or -1 if error. numberOfPresetsOut will be set to total number of presets available. See TrackFX_SetPresetByIndex
REAPERAPI_DECLFUNC(int,TrackFX_GetPresetIndex)(MediaTrack* track, int fx, int* numberOfPresetsOut);

// presetmove==1 activates the next preset, presetmove==-1 activates the previous preset, etc.
REAPERAPI_DECLFUNC(bool,TrackFX_NavigatePresets)(MediaTrack* track, int fx, int presetmove);

// See TrackFX_GetEnabled
REAPERAPI_DECLFUNC(void,TrackFX_SetEnabled)(MediaTrack* track, int fx, bool enabled);

// Enable or disable a ReaEQ band.
// Returns false if track/fxidx is not ReaEQ.
// Bandtype: 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx: 0=first band matching bandtype, 1=2nd band matching bandtype, etc.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_SetEQParam, TrackFX_GetEQBandEnabled.
REAPERAPI_DECLFUNC(bool,TrackFX_SetEQBandEnabled)(MediaTrack* track, int fxidx, int bandtype, int bandidx, bool enable);

// Returns false if track/fxidx is not ReaEQ. Targets a band matching bandtype.
// Bandtype: -1=master gain, 0=lhipass, 1=loshelf, 2=band, 3=notch, 4=hishelf, 5=lopass.
// Bandidx (ignored for master gain): 0=target first band matching bandtype, 1=target 2nd band matching bandtype, etc.
// Paramtype (ignored for master gain): 0=freq, 1=gain, 2=Q.
// See TrackFX_GetEQ, TrackFX_GetEQParam, TrackFX_GetEQBandEnabled, TrackFX_SetEQBandEnabled.
REAPERAPI_DECLFUNC(bool,TrackFX_SetEQParam)(MediaTrack* track, int fxidx, int bandtype, int bandidx, int paramtype, double val, bool isnorm);

// Open this FX UI. See TrackFX_GetOpen
REAPERAPI_DECLFUNC(void,TrackFX_SetOpen)(MediaTrack* track, int fx, bool open);

REAPERAPI_DECLFUNC(bool,TrackFX_SetParam)(MediaTrack* track, int fx, int param, double val);

REAPERAPI_DECLFUNC(bool,TrackFX_SetParamNormalized)(MediaTrack* track, int fx, int param, double value);

// See TrackFX_GetPreset
REAPERAPI_DECLFUNC(bool,TrackFX_SetPreset)(MediaTrack* track, int fx, const char* presetname);

// Sets preset idx for fx fx. Returns true on success.See TrackFX_GetPresetIndex
REAPERAPI_DECLFUNC(bool,TrackFX_SetPresetByIndex)(MediaTrack* track, int fx, int idx);

// showflag=0 for hidechain, =1 for show chain(index valid), =2 for hide floating window(index valid), =3 for show floating window (index valid)
REAPERAPI_DECLFUNC(void,TrackFX_Show)(MediaTrack* track, int index, int showFlag);

REAPERAPI_DECLFUNC(void,TrackList_AdjustWindows)(bool isMinor);

REAPERAPI_DECLFUNC(void,TrackList_UpdateAllExternalSurfaces)();

// call to start a new block
REAPERAPI_DECLFUNC(void,Undo_BeginBlock)();

// call to start a new block
REAPERAPI_DECLFUNC(void,Undo_BeginBlock2)(ReaProject* proj);

// returns string of next action,if able,NULL if not
REAPERAPI_DECLFUNC(const char*,Undo_CanRedo2)(ReaProject* proj);

// returns string of last action,if able,NULL if not
REAPERAPI_DECLFUNC(const char*,Undo_CanUndo2)(ReaProject* proj);

// nonzero if success
REAPERAPI_DECLFUNC(int,Undo_DoRedo2)(ReaProject* proj);

// nonzero if success
REAPERAPI_DECLFUNC(int,Undo_DoUndo2)(ReaProject* proj);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECLFUNC(void,Undo_EndBlock)(const char* descchange, int extraflags);

// call to end the block,with extra flags if any,and a description
REAPERAPI_DECLFUNC(void,Undo_EndBlock2)(ReaProject* proj, const char* descchange, int extraflags);

// limited state change to items
REAPERAPI_DECLFUNC(void,Undo_OnStateChange)(const char* descchange);

// limited state change to items
REAPERAPI_DECLFUNC(void,Undo_OnStateChange2)(ReaProject* proj, const char* descchange);

REAPERAPI_DECLFUNC(void,Undo_OnStateChange_Item)(ReaProject* proj, const char* name, MediaItem* item);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECLFUNC(void,Undo_OnStateChangeEx)(const char* descchange, int whichStates, int trackparm);

// trackparm=-1 by default,or if updating one fx chain,you can specify track index
REAPERAPI_DECLFUNC(void,Undo_OnStateChangeEx2)(ReaProject* proj, const char* descchange, int whichStates, int trackparm);

// Updates disk I/O statistics with bytes transferred since last call.
REAPERAPI_DECLFUNC(void,update_disk_counters)(int readamt, int writeamt);

// Redraw the arrange view
REAPERAPI_DECLFUNC(void,UpdateArrange)();

REAPERAPI_DECLFUNC(void,UpdateItemInProject)(MediaItem* item);

// Redraw the arrange view and ruler
REAPERAPI_DECLFUNC(void,UpdateTimeline)();

// returns true if the pointer is a valid object of the right type
REAPERAPI_DECLFUNC(bool,ValidatePtr)(void* pointer, const char* ctypename);

// Opens the prefs to a page, use pageByName if page is 0.
REAPERAPI_DECLFUNC(void,ViewPrefs)(int page, const char* pageByName);

REAPERAPI_DECLFUNC(bool,WDL_VirtualWnd_ScaledBlitBG)(LICE_IBitmap* dest, WDL_VirtualWnd_BGCfg* src, int destx, int desty, int destw, int desth, int clipx, int clipy, int clipw, int cliph, float alpha, int mode);

#ifdef REAPER_PLUGIN_FUNCTIONS_IMPL_LOADFUNC
#if defined(__RPFI)
#error oops __RPFI already defined?!
#endif
int REAPERAPI_LoadAPI(void *(*getAPI)(const char *))
{
  #define __RPFI(x) {(void**)&REAPERAPI_STUBNAME(x),#x},
  struct { void **dest; const char *name; } table[]={
    __RPFI(__mergesort) __RPFI(AddCustomizableMenu) __RPFI(AddExtensionsMainMenu) __RPFI(AddMediaItemToTrack) 
    __RPFI(AddProjectMarker) __RPFI(AddProjectMarker2) __RPFI(AddTakeToMediaItem) __RPFI(AddTempoTimeSigMarker) 
    __RPFI(adjustZoom) __RPFI(AnyTrackSolo) __RPFI(APITest) __RPFI(ApplyNudge) 
    __RPFI(Audio_IsPreBuffer) __RPFI(Audio_IsRunning) __RPFI(Audio_RegHardwareHook) __RPFI(AudioAccessorValidateState) 
    __RPFI(BypassFxAllTracks) __RPFI(CalculatePeaks) __RPFI(CalculatePeaksFloatSrcPtr) __RPFI(ClearAllRecArmed) 
    __RPFI(ClearPeakCache) __RPFI(CountActionShortcuts) __RPFI(CountMediaItems) __RPFI(CountProjectMarkers) 
    __RPFI(CountSelectedMediaItems) __RPFI(CountSelectedTracks) __RPFI(CountTakes) __RPFI(CountTCPFXParms) 
    __RPFI(CountTempoTimeSigMarkers) __RPFI(CountTrackEnvelopes) __RPFI(CountTrackMediaItems) __RPFI(CountTracks) 
    __RPFI(CreateLocalOscHandler) __RPFI(CreateMIDIInput) __RPFI(CreateMIDIOutput) __RPFI(CreateNewMIDIItemInProj) 
    __RPFI(CreateTakeAudioAccessor) __RPFI(CreateTrackAudioAccessor) __RPFI(CSurf_FlushUndo) __RPFI(CSurf_GetTouchState) 
    __RPFI(CSurf_GoEnd) __RPFI(CSurf_GoStart) __RPFI(CSurf_NumTracks) __RPFI(CSurf_OnArrow) 
    __RPFI(CSurf_OnFwd) __RPFI(CSurf_OnFXChange) __RPFI(CSurf_OnInputMonitorChange) __RPFI(CSurf_OnInputMonitorChangeEx) 
    __RPFI(CSurf_OnMuteChange) __RPFI(CSurf_OnMuteChangeEx) __RPFI(CSurf_OnOscControlMessage) __RPFI(CSurf_OnPanChange) 
    __RPFI(CSurf_OnPanChangeEx) __RPFI(CSurf_OnPause) __RPFI(CSurf_OnPlay) __RPFI(CSurf_OnPlayRateChange) 
    __RPFI(CSurf_OnRecArmChange) __RPFI(CSurf_OnRecArmChangeEx) __RPFI(CSurf_OnRecord) __RPFI(CSurf_OnRecvPanChange) 
    __RPFI(CSurf_OnRecvVolumeChange) __RPFI(CSurf_OnRew) __RPFI(CSurf_OnRewFwd) __RPFI(CSurf_OnScroll) 
    __RPFI(CSurf_OnSelectedChange) __RPFI(CSurf_OnSendPanChange) __RPFI(CSurf_OnSendVolumeChange) __RPFI(CSurf_OnSoloChange) 
    __RPFI(CSurf_OnSoloChangeEx) __RPFI(CSurf_OnStop) __RPFI(CSurf_OnTempoChange) __RPFI(CSurf_OnTrackSelection) 
    __RPFI(CSurf_OnVolumeChange) __RPFI(CSurf_OnVolumeChangeEx) __RPFI(CSurf_OnWidthChange) __RPFI(CSurf_OnWidthChangeEx) 
    __RPFI(CSurf_OnZoom) __RPFI(CSurf_ResetAllCachedVolPanStates) __RPFI(CSurf_ScrubAmt) __RPFI(CSurf_SetAutoMode) 
    __RPFI(CSurf_SetPlayState) __RPFI(CSurf_SetRepeatState) __RPFI(CSurf_SetSurfaceMute) __RPFI(CSurf_SetSurfacePan) 
    __RPFI(CSurf_SetSurfaceRecArm) __RPFI(CSurf_SetSurfaceSelected) __RPFI(CSurf_SetSurfaceSolo) __RPFI(CSurf_SetSurfaceVolume) 
    __RPFI(CSurf_SetTrackListChange) __RPFI(CSurf_TrackFromID) __RPFI(CSurf_TrackToID) __RPFI(DB2SLIDER) 
    __RPFI(DeleteActionShortcut) __RPFI(DeleteExtState) __RPFI(DeleteProjectMarker) __RPFI(DeleteProjectMarkerByIndex) 
    __RPFI(DeleteTakeStretchMarkers) __RPFI(DeleteTrack) __RPFI(DeleteTrackMediaItem) __RPFI(DestroyAudioAccessor) 
    __RPFI(DestroyLocalOscHandler) __RPFI(DoActionShortcutDialog) __RPFI(Dock_UpdateDockID) __RPFI(DockIsChildOfDock) 
    __RPFI(DockWindowActivate) __RPFI(DockWindowAdd) __RPFI(DockWindowAddEx) __RPFI(DockWindowRefresh) 
    __RPFI(DockWindowRefreshForHWND) __RPFI(DockWindowRemove) __RPFI(DuplicateCustomizableMenu) __RPFI(EnsureNotCompletelyOffscreen) 
    __RPFI(EnumPitchShiftModes) __RPFI(EnumPitchShiftSubModes) __RPFI(EnumProjectMarkers) __RPFI(EnumProjectMarkers2) 
    __RPFI(EnumProjectMarkers3) __RPFI(EnumProjects) __RPFI(EnumRegionRenderMatrix) __RPFI(EnumTrackMIDIProgramNames) 
    __RPFI(EnumTrackMIDIProgramNamesEx) __RPFI(file_exists) __RPFI(format_timestr) __RPFI(format_timestr_len) 
    __RPFI(format_timestr_pos) __RPFI(FreeHeapPtr) __RPFI(genGuid) __RPFI(get_config_var) 
    __RPFI(get_ini_file) __RPFI(get_midi_config_var) __RPFI(GetActionShortcutDesc) __RPFI(GetActiveTake) 
    __RPFI(GetAppVersion) __RPFI(GetAudioAccessorEndTime) __RPFI(GetAudioAccessorHash) __RPFI(GetAudioAccessorSamples) 
    __RPFI(GetAudioAccessorStartTime) __RPFI(GetColorTheme) __RPFI(GetColorThemeStruct) __RPFI(GetConfigWantsDock) 
    __RPFI(GetContextMenu) __RPFI(GetCurrentProjectInLoadSave) __RPFI(GetCursorContext) __RPFI(GetCursorContext2) 
    __RPFI(GetCursorPosition) __RPFI(GetCursorPositionEx) __RPFI(GetDisplayedMediaItemColor) __RPFI(GetDisplayedMediaItemColor2) 
    __RPFI(GetEnvelopeName) __RPFI(GetExePath) __RPFI(GetExtState) __RPFI(GetFocusedFX) 
    __RPFI(GetFreeDiskSpaceForRecordPath) __RPFI(GetGlobalAutomationOverride) __RPFI(GetHZoomLevel) __RPFI(GetIconThemePointer) 
    __RPFI(GetIconThemeStruct) __RPFI(GetInputChannelName) __RPFI(GetInputOutputLatency) __RPFI(GetItemEditingTime2) 
    __RPFI(GetItemProjectContext) __RPFI(GetLastMarkerAndCurRegion) __RPFI(GetLastTouchedFX) __RPFI(GetLastTouchedTrack) 
    __RPFI(GetMainHwnd) __RPFI(GetMasterMuteSoloFlags) __RPFI(GetMasterTrack) __RPFI(GetMasterTrackVisibility) 
    __RPFI(GetMaxMidiInputs) __RPFI(GetMaxMidiOutputs) __RPFI(GetMediaItem) __RPFI(GetMediaItem_Track) 
    __RPFI(GetMediaItemInfo_Value) __RPFI(GetMediaItemNumTakes) __RPFI(GetMediaItemTake) __RPFI(GetMediaItemTake_Item) 
    __RPFI(GetMediaItemTake_Source) __RPFI(GetMediaItemTake_Track) __RPFI(GetMediaItemTakeByGUID) __RPFI(GetMediaItemTakeInfo_Value) 
    __RPFI(GetMediaItemTrack) __RPFI(GetMediaSourceFileName) __RPFI(GetMediaSourceNumChannels) __RPFI(GetMediaSourceSampleRate) 
    __RPFI(GetMediaSourceType) __RPFI(GetMediaTrackInfo_Value) __RPFI(GetMidiInput) __RPFI(GetMIDIInputName) 
    __RPFI(GetMidiOutput) __RPFI(GetMIDIOutputName) __RPFI(GetMixerScroll) __RPFI(GetMouseModifier) 
    __RPFI(GetNumAudioInputs) __RPFI(GetNumAudioOutputs) __RPFI(GetNumMIDIInputs) __RPFI(GetNumMIDIOutputs) 
    __RPFI(GetNumTracks) __RPFI(GetOutputChannelName) __RPFI(GetOutputLatency) __RPFI(GetParentTrack) 
    __RPFI(GetPeakFileName) __RPFI(GetPeakFileNameEx) __RPFI(GetPeakFileNameEx2) __RPFI(GetPeaksBitmap) 
    __RPFI(GetPlayPosition) __RPFI(GetPlayPosition2) __RPFI(GetPlayPosition2Ex) __RPFI(GetPlayPositionEx) 
    __RPFI(GetPlayState) __RPFI(GetPlayStateEx) __RPFI(GetPreferredDiskReadMode) __RPFI(GetPreferredDiskReadModePeak) 
    __RPFI(GetPreferredDiskWriteMode) __RPFI(GetProjectPath) __RPFI(GetProjectPathEx) __RPFI(GetProjectStateChangeCount) 
    __RPFI(GetProjectTimeSignature) __RPFI(GetProjectTimeSignature2) __RPFI(GetResourcePath) __RPFI(GetSelectedEnvelope) 
    __RPFI(GetSelectedMediaItem) __RPFI(GetSelectedTrack) __RPFI(GetSelectedTrackEnvelope) __RPFI(GetSet_ArrangeView2) 
    __RPFI(GetSet_LoopTimeRange) __RPFI(GetSet_LoopTimeRange2) __RPFI(GetSetEnvelopeState) __RPFI(GetSetEnvelopeState2) 
    __RPFI(GetSetItemState) __RPFI(GetSetItemState2) __RPFI(GetSetMediaItemInfo) __RPFI(GetSetMediaItemTakeInfo) 
    __RPFI(GetSetMediaItemTakeInfo_String) __RPFI(GetSetMediaTrackInfo) __RPFI(GetSetMediaTrackInfo_String) __RPFI(GetSetObjectState) 
    __RPFI(GetSetObjectState2) __RPFI(GetSetRepeat) __RPFI(GetSetRepeatEx) __RPFI(GetSetTrackMIDISupportFile) 
    __RPFI(GetSetTrackSendInfo) __RPFI(GetSetTrackState) __RPFI(GetSetTrackState2) __RPFI(GetSubProjectFromSource) 
    __RPFI(GetTake) __RPFI(GetTakeEnvelopeByName) __RPFI(GetTakeName) __RPFI(GetTakeNumStretchMarkers) 
    __RPFI(GetTakeStretchMarker) __RPFI(GetTCPFXParm) __RPFI(GetTempoMatchPlayRate) __RPFI(GetTempoTimeSigMarker) 
    __RPFI(GetToggleCommandState) __RPFI(GetToggleCommandState2) __RPFI(GetToggleCommandStateThroughHooks) __RPFI(GetTooltipWindow) 
    __RPFI(GetTrack) __RPFI(GetTrackAutomationMode) __RPFI(GetTrackColor) __RPFI(GetTrackDepth) 
    __RPFI(GetTrackEnvelope) __RPFI(GetTrackEnvelopeByName) __RPFI(GetTrackGUID) __RPFI(GetTrackInfo) 
    __RPFI(GetTrackMediaItem) __RPFI(GetTrackMIDINoteName) __RPFI(GetTrackMIDINoteNameEx) __RPFI(GetTrackMIDINoteRange) 
    __RPFI(GetTrackNumMediaItems) __RPFI(GetTrackNumSends) __RPFI(GetTrackReceiveName) __RPFI(GetTrackReceiveUIMute) 
    __RPFI(GetTrackReceiveUIVolPan) __RPFI(GetTrackSendName) __RPFI(GetTrackSendUIMute) __RPFI(GetTrackSendUIVolPan) 
    __RPFI(GetTrackState) __RPFI(GetTrackUIMute) __RPFI(GetTrackUIPan) __RPFI(GetTrackUIVolPan) 
    __RPFI(GetUserFileNameForRead) __RPFI(GetUserInputs) __RPFI(GoToMarker) __RPFI(GoToRegion) 
    __RPFI(GR_SelectColor) __RPFI(GSC_mainwnd) __RPFI(guidToString) __RPFI(HasExtState) 
    __RPFI(HasTrackMIDIPrograms) __RPFI(HasTrackMIDIProgramsEx) __RPFI(Help_Set) __RPFI(HiresPeaksFromSource) 
    __RPFI(image_resolve_fn) __RPFI(InsertMedia) __RPFI(InsertMediaSection) __RPFI(InsertTrackAtIndex) 
    __RPFI(IsInRealTimeAudio) __RPFI(IsItemTakeActiveForPlayback) __RPFI(IsMediaExtension) __RPFI(IsMediaItemSelected) 
    __RPFI(IsREAPER) __RPFI(IsTrackSelected) __RPFI(IsTrackVisible) __RPFI(kbd_enumerateActions) 
    __RPFI(kbd_formatKeyName) __RPFI(kbd_getCommandName) __RPFI(kbd_getTextFromCmd) __RPFI(KBD_OnMainActionEx) 
    __RPFI(kbd_OnMidiEvent) __RPFI(kbd_OnMidiList) __RPFI(kbd_ProcessActionsMenu) __RPFI(kbd_processMidiEventActionEx) 
    __RPFI(kbd_reprocessMenu) __RPFI(kbd_RunCommandThroughHooks) __RPFI(kbd_translateAccelerator) __RPFI(kbd_translateMouse) 


#ifndef REAPERAPI_NO_LICE
    __RPFI(LICE__Destroy) __RPFI(LICE__DestroyFont) __RPFI(LICE__DrawText) __RPFI(LICE__GetBits) 
    __RPFI(LICE__GetDC) __RPFI(LICE__GetHeight) __RPFI(LICE__GetRowSpan) __RPFI(LICE__GetWidth) 
    __RPFI(LICE__IsFlipped) __RPFI(LICE__resize) __RPFI(LICE__SetBkColor) __RPFI(LICE__SetFromHFont) 
    __RPFI(LICE__SetTextColor) __RPFI(LICE__SetTextCombineMode) __RPFI(LICE_Arc) __RPFI(LICE_Blit) 
    __RPFI(LICE_Blur) __RPFI(LICE_BorderedRect) __RPFI(LICE_Circle) __RPFI(LICE_Clear) 
    __RPFI(LICE_ClearRect) __RPFI(LICE_ClipLine) __RPFI(LICE_Copy) __RPFI(LICE_CreateBitmap) 
    __RPFI(LICE_CreateFont) __RPFI(LICE_DrawChar) __RPFI(LICE_DrawGlyph) __RPFI(LICE_DrawRect) 
    __RPFI(LICE_DrawText) __RPFI(LICE_FillCircle) __RPFI(LICE_FillConvexPolygon) __RPFI(LICE_FillRect) 
    __RPFI(LICE_FillTrapezoid) __RPFI(LICE_FillTriangle) __RPFI(LICE_GetPixel) __RPFI(LICE_GradRect) 
    __RPFI(LICE_Line) __RPFI(LICE_LineInt) __RPFI(LICE_LoadPNG) __RPFI(LICE_LoadPNGFromResource) 
    __RPFI(LICE_MeasureText) __RPFI(LICE_MultiplyAddRect) __RPFI(LICE_PutPixel) __RPFI(LICE_RotatedBlit) 
    __RPFI(LICE_RoundRect) __RPFI(LICE_ScaledBlit) __RPFI(LICE_SimpleFill) 
#endif // !REAPERAPI_NO_LICE

    __RPFI(Loop_OnArrow) __RPFI(Main_OnCommand) __RPFI(Main_OnCommandEx) __RPFI(Main_openProject) 
    __RPFI(Main_UpdateLoopInfo) __RPFI(MarkProjectDirty) __RPFI(MarkTrackItemsDirty) __RPFI(Master_GetPlayRate) 
    __RPFI(Master_GetPlayRateAtTime) __RPFI(Master_GetTempo) __RPFI(Master_NormalizePlayRate) __RPFI(Master_NormalizeTempo) 
    __RPFI(MB) __RPFI(MediaItemDescendsFromTrack) __RPFI(MIDI_CountEvts) __RPFI(MIDI_DeleteCC) 
    __RPFI(MIDI_DeleteEvt) __RPFI(MIDI_DeleteNote) __RPFI(MIDI_DeleteTextSysexEvt) __RPFI(MIDI_EnumSelCC) 
    __RPFI(MIDI_EnumSelEvts) __RPFI(MIDI_EnumSelNotes) __RPFI(MIDI_EnumSelTextSysexEvts) __RPFI(MIDI_eventlist_Create) 
    __RPFI(MIDI_eventlist_Destroy) __RPFI(MIDI_GetCC) __RPFI(MIDI_GetEvt) __RPFI(MIDI_GetNote) 
    __RPFI(MIDI_GetPPQPos_EndOfMeasure) __RPFI(MIDI_GetPPQPos_StartOfMeasure) __RPFI(MIDI_GetPPQPosFromProjTime) __RPFI(MIDI_GetProjTimeFromPPQPos) 
    __RPFI(MIDI_GetTextSysexEvt) __RPFI(MIDI_InsertCC) __RPFI(MIDI_InsertEvt) __RPFI(MIDI_InsertNote) 
    __RPFI(MIDI_InsertTextSysexEvt) __RPFI(midi_reinit) __RPFI(MIDI_SetCC) __RPFI(MIDI_SetEvt) 
    __RPFI(MIDI_SetNote) __RPFI(MIDI_SetTextSysexEvt) __RPFI(MIDIEditor_GetActive) __RPFI(MIDIEditor_GetMode) 
    __RPFI(MIDIEditor_GetSetting_int) __RPFI(MIDIEditor_GetSetting_str) __RPFI(MIDIEditor_GetTake) __RPFI(MIDIEditor_LastFocused_OnCommand) 
    __RPFI(MIDIEditor_OnCommand) __RPFI(mkpanstr) __RPFI(mkvolpanstr) __RPFI(mkvolstr) 
    __RPFI(MoveEditCursor) __RPFI(MoveMediaItemToTrack) __RPFI(MuteAllTracks) __RPFI(my_getViewport) 
    __RPFI(NamedCommandLookup) __RPFI(OnPauseButton) __RPFI(OnPauseButtonEx) __RPFI(OnPlayButton) 
    __RPFI(OnPlayButtonEx) __RPFI(OnStopButton) __RPFI(OnStopButtonEx) __RPFI(OscLocalMessageToHost) 
    __RPFI(parse_timestr) __RPFI(parse_timestr_len) __RPFI(parse_timestr_pos) __RPFI(parsepanstr) 
    __RPFI(PCM_Sink_Create) __RPFI(PCM_Sink_CreateEx) __RPFI(PCM_Sink_CreateMIDIFile) __RPFI(PCM_Sink_CreateMIDIFileEx) 
    __RPFI(PCM_Sink_Enum) __RPFI(PCM_Sink_GetExtension) __RPFI(PCM_Sink_ShowConfig) __RPFI(PCM_Source_CreateFromFile) 
    __RPFI(PCM_Source_CreateFromFileEx) __RPFI(PCM_Source_CreateFromSimple) __RPFI(PCM_Source_CreateFromType) __RPFI(PCM_Source_GetSectionInfo) 
    __RPFI(PeakBuild_Create) __RPFI(PeakGet_Create) __RPFI(PlayPreview) __RPFI(PlayPreviewEx) 
    __RPFI(PlayTrackPreview) __RPFI(PlayTrackPreview2) __RPFI(PlayTrackPreview2Ex) __RPFI(plugin_getapi) 
    __RPFI(plugin_getFilterList) __RPFI(plugin_getImportableProjectFilterList) __RPFI(plugin_register) __RPFI(PluginWantsAlwaysRunFx) 
    __RPFI(PreventUIRefresh) __RPFI(projectconfig_var_addr) __RPFI(projectconfig_var_getoffs) __RPFI(ReaperGetPitchShiftAPI) 
    __RPFI(ReaScriptError) __RPFI(RecursiveCreateDirectory) __RPFI(RefreshToolbar) __RPFI(relative_fn) 
    __RPFI(RenderFileSection) __RPFI(Resample_EnumModes) __RPFI(Resampler_Create) __RPFI(resolve_fn) 
    __RPFI(resolve_fn2) __RPFI(ReverseNamedCommandLookup) __RPFI(screenset_register) __RPFI(screenset_registerNew) 
    __RPFI(screenset_unregister) __RPFI(screenset_unregisterByParam) __RPFI(SectionFromUniqueID) __RPFI(SelectAllMediaItems) 
    __RPFI(SelectProjectInstance) __RPFI(SendLocalOscMessage) __RPFI(SetActiveTake) __RPFI(SetAutomationMode) 
    __RPFI(SetCurrentBPM) __RPFI(SetCursorContext) __RPFI(SetEditCurPos) __RPFI(SetEditCurPos2) 
    __RPFI(SetExtState) __RPFI(SetGlobalAutomationOverride) __RPFI(SetMasterTrackVisibility) __RPFI(SetMediaItemInfo_Value) 
    __RPFI(SetMediaItemLength) __RPFI(SetMediaItemPosition) __RPFI(SetMediaItemSelected) __RPFI(SetMediaItemTakeInfo_Value) 
    __RPFI(SetMediaTrackInfo_Value) __RPFI(SetMixerScroll) __RPFI(SetMouseModifier) __RPFI(SetOnlyTrackSelected) 
    __RPFI(SetProjectMarker) __RPFI(SetProjectMarker2) __RPFI(SetProjectMarker3) __RPFI(SetProjectMarker4) 
    __RPFI(SetProjectMarkerByIndex) __RPFI(SetProjectMarkerByIndex2) __RPFI(SetRegionRenderMatrix) __RPFI(SetRenderLastError) 
    __RPFI(SetTakeStretchMarker) __RPFI(SetTempoTimeSigMarker) __RPFI(SetTrackAutomationMode) __RPFI(SetTrackColor) 
    __RPFI(SetTrackMIDINoteName) __RPFI(SetTrackMIDINoteNameEx) __RPFI(SetTrackSelected) __RPFI(SetTrackSendUIPan) 
    __RPFI(SetTrackSendUIVol) __RPFI(ShowActionList) __RPFI(ShowConsoleMsg) __RPFI(ShowMessageBox) 
    __RPFI(SLIDER2DB) __RPFI(SnapToGrid) __RPFI(SoloAllTracks) __RPFI(Splash_GetWnd) 
    __RPFI(SplitMediaItem) __RPFI(StopPreview) __RPFI(StopTrackPreview) __RPFI(StopTrackPreview2) 
    __RPFI(stringToGuid) __RPFI(StuffMIDIMessage) __RPFI(TimeMap2_beatsToTime) __RPFI(TimeMap2_GetDividedBpmAtTime) 
    __RPFI(TimeMap2_GetNextChangeTime) __RPFI(TimeMap2_QNToTime) __RPFI(TimeMap2_timeToBeats) __RPFI(TimeMap2_timeToQN) 
    __RPFI(TimeMap_curFrameRate) __RPFI(TimeMap_GetDividedBpmAtTime) __RPFI(TimeMap_GetTimeSigAtTime) __RPFI(TimeMap_QNToTime) 
    __RPFI(TimeMap_QNToTime_abs) __RPFI(TimeMap_timeToQN) __RPFI(TimeMap_timeToQN_abs) __RPFI(ToggleTrackSendUIMute) 
    __RPFI(Track_GetPeakHoldDB) __RPFI(Track_GetPeakInfo) __RPFI(TrackCtl_SetToolTip) __RPFI(TrackFX_EndParamEdit) 
    __RPFI(TrackFX_FormatParamValue) __RPFI(TrackFX_FormatParamValueNormalized) __RPFI(TrackFX_GetByName) __RPFI(TrackFX_GetChainVisible) 
    __RPFI(TrackFX_GetCount) __RPFI(TrackFX_GetEnabled) __RPFI(TrackFX_GetEQ) __RPFI(TrackFX_GetEQBandEnabled) 
    __RPFI(TrackFX_GetEQParam) __RPFI(TrackFX_GetFloatingWindow) __RPFI(TrackFX_GetFormattedParamValue) __RPFI(TrackFX_GetFXGUID) 
    __RPFI(TrackFX_GetFXName) __RPFI(TrackFX_GetInstrument) __RPFI(TrackFX_GetNumParams) __RPFI(TrackFX_GetOpen) 
    __RPFI(TrackFX_GetParam) __RPFI(TrackFX_GetParameterStepSizes) __RPFI(TrackFX_GetParamEx) __RPFI(TrackFX_GetParamName) 
    __RPFI(TrackFX_GetParamNormalized) __RPFI(TrackFX_GetPreset) __RPFI(TrackFX_GetPresetIndex) __RPFI(TrackFX_NavigatePresets) 
    __RPFI(TrackFX_SetEnabled) __RPFI(TrackFX_SetEQBandEnabled) __RPFI(TrackFX_SetEQParam) __RPFI(TrackFX_SetOpen) 
    __RPFI(TrackFX_SetParam) __RPFI(TrackFX_SetParamNormalized) __RPFI(TrackFX_SetPreset) __RPFI(TrackFX_SetPresetByIndex) 
    __RPFI(TrackFX_Show) __RPFI(TrackList_AdjustWindows) __RPFI(TrackList_UpdateAllExternalSurfaces) __RPFI(Undo_BeginBlock) 
    __RPFI(Undo_BeginBlock2) __RPFI(Undo_CanRedo2) __RPFI(Undo_CanUndo2) __RPFI(Undo_DoRedo2) 
    __RPFI(Undo_DoUndo2) __RPFI(Undo_EndBlock) __RPFI(Undo_EndBlock2) __RPFI(Undo_OnStateChange) 
    __RPFI(Undo_OnStateChange2) __RPFI(Undo_OnStateChange_Item) __RPFI(Undo_OnStateChangeEx) __RPFI(Undo_OnStateChangeEx2) 
    __RPFI(update_disk_counters) __RPFI(UpdateArrange) __RPFI(UpdateItemInProject) __RPFI(UpdateTimeline) 
    __RPFI(ValidatePtr) __RPFI(ViewPrefs) __RPFI(WDL_VirtualWnd_ScaledBlitBG) 
  };
  int i,failcnt=0;
  for (i=0;i<sizeof(table)/sizeof(table[0]); i++)
    failcnt += !(*table[i].dest = getAPI(table[i].name));
  return failcnt;
  #undef __RPFI
}
#endif //REAPER_PLUGIN_FUNCTIONS_IMPL_LOADFUNC
#endif // _REAPER_PLUGIN_FUNCTIONS_H_

